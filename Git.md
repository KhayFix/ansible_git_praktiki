# Git

## Зачем

Мы храним в git-репо наши инструменты: проекты Ansible, Terraform, и даже эту документацию.  
Git дает нам  следующие возможности:  

* **Версионность изменений**  
    Позволяет нам вносить правки осмысленными частями(коммитами).  
    Вся история коммитов всегда доступна для просмотра и поиска.  
* **Обратимость изменений**  
    Мы всегда можем откатить до определенного коммита как весь репозиторий, так и только несколько файлов.  
    Работает поиск по изменениям, и мы всегда можем найти коммит, в котором были внесены те или иные изменения.  
* **Независимость изменений**  
    До момент слияния нашей ветки с другой веткой мы не испытываем никакого влияния изменений из других веток.
* **CI**  
    Мы можем прогонять автоматизированные действия как на каждый коммит, так и при определенных условиях.  
    Это позволяет реализовать различные автотесты и автовыкладки.  
* **Ревью изменений**  
    Позволяет нам удобно проводить коллективную оценку изменений перед их слиянием с другими ветками.

## Как

### Коммиты

Коммит - минимальная единца изменений в Git.  
Именования коммитов и кол-во изменений в одном коммите - большая и сложная тема, вот основные моменты:  

* **Идентификатор задачи**  
    Сообщение или мета коммита должна иметь в себе идентификатор задачи.  
    Это позволит вашим коллегам и вам понимать, какую глобальную задачу решали те или иные коммиты.  
    Это знание не потеряется при увольнении сотрудника или приступе амнезии у оного,  
    и навсегда остается в истории коммитов и таск-трекере.  

    _Плохой пример:_  

    ```plain
    New role
    Fix role
    Fix fix
    ADMGROUP-124
    ```

* **Размер и стиль сообщения**  
    В идеале должно быть не меньше 8 и не больше 52 символов  
    Избегайте:

    * использования языка, отличного от американского английского  
    * попыток нумеровать коммиты
    * нерелевантной информации  
    * размашистых оборотов речи  
    * сложных времен для глаголов  
    * большого кол-ва вспомогательных слов.  

    _Плохой пример:_  

    ```plain
    This is my new fancy role for DNS Slave deployment. I have wrote it cause old role was makin' me sad. It' s rockin' hard!
    Новая роль для ДНС.
    Dns role 2.
    ```

* **Смысл сообщения**  
    Не дублируйте в сообщении то, что и так видно в коммите.  
    Если неочевиден смысл изменений, то нужно пояснить ПОЧЕМУ изменения именно такие.  
    Если смысл очевиден, то просто дайте общее название данным изменениям.  

    _Плохой пример:_  

    ```plain
    Changes 'no' to 'false' in role 'rsyslog'
    ```

_Пример хорошего сообщения коммита:_  

```plain
ADMGROUP-124 Initial role
ADMGROUP-124 Lint role
ADMGROUP-124 Fix typos
ADMGROUP-124 Idemptotence for DNS reload
```

### Ветки

Мы используем ветку **master** для актуального состояния прода.  
Если что-то применено к проду, то оно должно быть в мастере.  
Всю разработку новых инструментов мы ведем в отдельных ветках одного из двух типов:

* **feature**  
    Ветки для разработки нового фукционала или доработки существующего.

* **bugfix**  
    Ветки для условно-оперативного исправления каких-либо проблем на проде или в работе инструментов.

_Мы не используем hotfix-ветки, т. к. они не имеют особенного смысла при отстутствии дев-ветки и релизных веток._  

Ветки именуются след. образом:  
`тип_ветки/идентификатор_задачи-краткое_описание`  

_Пример:_  

```bash
feature/ADMGROUP-124-new-dns-role
feature/SUPPORT-39-rpndzr-db-hosts
feature/MGMT-81-updated-salary-rules

bugfix/ADMGROUP-124-revert-global-repo-url
bugfix/SUPPORT-39-remove-dublicates
bugfix/MGMT-81-fix-mistyped-salaries
```

### Реквесты/ревью

## Инструменты и примеры

### Схлопнуть несколько локальных коммитов в один

Закончили тестирование в отдельной ветке, и хотим подчистить дублирующие коммиты.

* Бэкапим в отдельный бранч на всякий случай `git branch my_backup_branch`
* Вызываем `git cherry -v master`, считаем глубину до нижнего коммита, который мы хотим сжать.  
    **Внимательно** проверяем, что на этой глубине **нет merge-коммитов**.  
    Если они есть, то схлопнуть этим коммиты **не получится**.  
* Делаем `git rebase -i HEAD~N`, где N - кол-во коммитов на сжатие  
* Откроется редактор  с редактированием списка коммитов  
    _Редактор может быть разным, зависит от переменной окружений EDITOR._  
    _Точно нормально работает с Vim/nano/emacs/mcedit._  
    * верхний коммит трогать нельзя  
    * для "лишних" коммитов заменяем pick на s  
    * сохраняемся, выходим  
* Откроется редактор сообщения коммита, используем творческую силу, сохраняем, выходим  
* Повторно вызываеем `git cherry -v master`, проверяй, что теперь все выглядит правильно  
* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  

### Найти правки в строках N1-N2 файле X

Знаем, что в строках 6-8 файла README были правки, которые нам все сломали.  
Ищем коммиты, которые меняли эти строки:  

```bash
git blame -L 6,8 README.md
^756c345 (Sergei Mikhailov 2019-11-07 19:00:13 +0300 6)
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 7) ## Ручной запуск тестов
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 8)
```

Смотрим информацию по последнему коммиту:  

```bash
git show e0b9f53a README.md
commit e0b9f53a7e461053f7bf099231bf6a35dfbc1c1b (HEAD -> feature/common-pain, origin/feature/common-pain)
Author: Sergei Mikhailov <s.mikhaylov@tgk-ws.ru>
Date:   Fri Nov 8 12:07:32 2019 +0300

    Basic lint

diff --git a/README.md b/README.md
index a89f606..cc1bcc5 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,12 @@
 # StyleConvention

-В этом репо живут наши соглашения о работе с различными инструментами.
+В этом репо живут наши соглашения о работе с различными инструментами.
 Правки применяются только через Merge Request с апрувом(посредством емодзи) от большинства сотрудников.
 За корректностью разметки и текстов приглядыют автотесты.

+## Ручной запуск тестов
+
+### markdownlint
+
+`docker run -it -v "$PWD:/code" pipelinecomponents/markdownlint:5d96213 mdl -s md.rb -w .`
```

### Откатить файл X на коммит Y

В рамках задачи MYTEAM-19 обнаружили, что коммит *e0b9f53a* ломает наш любимый README.md.  
Создаем отдельную ветку:

```bash
git branch bugfix/MYTEAM-19
git push --set-upstream origin bugfix/MYTEAM-19
```

Откатываем файл README.md на один коммит ранее *e0b9f53a*:

```bash
git reset e0b9f53a~1 README.md
Unstaged changes after reset:
M       README.md
```

Закидываем эти правки:

```bash
git commit -m 'MYTEAM-19 Revert to e0b9f53a~1 due to broken func'
git push
```

### Подтянуть себе правки из мастера и порешать конфликты

В веб-интерфейсе видим, что смерджить бранч *create-wobbler-role* нельзя: есть конфликты.  
Если до этого мы не делали merge-коммиты, то самым удобным будет сделать rebase.

* Проверяем, что все правки добавлены в коммиты:  
    `git status`

* Бэкапим в отдельный бранч на всякий случай:  
    `git branch my_backup_branch`

* Делаем rebase:

    ```bash
    git rebase origin/master
    First, rewinding head to replay your work on top of it...
    Applying: Update README.md
    Applying: check docker-compose
    Applying: check docker-compose1
    Applying: check docker-compose2
    Applying: check docker-compose3
    Applying: check docker-compose4
    Using index info to reconstruct a base tree...
    A       inventory/group_vars/t1000/all
    Falling back to patching base and 3-way merge...
    CONFLICT (modify/delete): inventory/group_vars/t1000/all deleted in HEAD and modified in check docker-compose4.
                              Version check docker-compose4 of inventory/group_vars/t1000/all left in tree.
    error: Failed to merge in the changes.
    Patch failed at 0006 check docker-compose4
    hint: Use 'git am --show-current-patch' to see the failed patch

    Resolve all conflicts manually, mark them as resolved with
    "git add/rm <conflicted_files>", then run "git rebase --continue".
    You can instead skip this commit: run "git rebase --skip".
    To abort and get back to the state before "git rebase", run "git rebase --abort".
    ```

* Теперь нужно решить конфликты. Следуем подсказкам git:

    ```bash
    git rm inventory/group_vars/t1000/all
    git rebase --continue
    git rebase --skip
    ```

    _В данном случае нам не нужно мерджить конфликты в файле, мы его просто удаляем, как его уже удалили в мастере._

* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  
