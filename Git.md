# Git

* [Необходимость Git](#необходимость-git)  
* [Сущности Git](#сущности-git)  
    * [Коммиты](#коммиты)  
    * [Ветки](#ветки)  
    * [Реквесты](#реквесты)  
    * [Code review](#code-review)  
        * [Что инспектировать в review](#что-инспектировать-в-review)  
        * [Кто и как проводит review](#кто-и-как-проводит-review)  
        * [Полезные практики code review](#полезные-практики-code-review)  
* [Типовые задачи в Git](#типовые-задачи-в-git)  
    * [Схлопнуть несколько локальных коммитов в один](#схлопнуть-несколько-локальных-коммитов-в-один)  
    * [Найти правки в строках N1-N2 файле X](#найти-правки-в-строках-n1-n2-файле-x)  
    * [Откатить файл X на коммит Y](#откатить-файл-x-на-коммит-y)  
    * [Подтянуть себе правки из мастера и порешать конфликты](#подтянуть-себе-правки-из-мастера-и-порешать-конфликты)

## Необходимость Git

Мы храним в git-репо наши инструменты: проекты Ansible, Terraform, и даже эту документацию.  
Git дает нам  следующие возможности:  

* **Версионность изменений**  
    Позволяет нам вносить правки осмысленными частями(коммитами).  
    Вся история коммитов всегда доступна для просмотра и поиска.  
* **Обратимость изменений**  
    Мы всегда можем откатить до определенного коммита как весь репозиторий, так и только несколько файлов.  
    Работает поиск по изменениям, и мы всегда можем найти коммит, в котором были внесены те или иные изменения.  
* **Независимость изменений**  
    До момент слияния нашей ветки с другой веткой мы не испытываем никакого влияния изменений из других веток.
* **CI**  
    Мы можем прогонять автоматизированные действия как на каждый коммит, так и при определенных условиях.  
    Это позволяет реализовать различные автотесты и автовыкладки.  
* **Ревью изменений**  
    Позволяет нам удобно проводить коллективную оценку изменений перед их слиянием с другими ветками.

## Сущности Git

### Коммиты

Коммит - минимальная единца изменений в Git.  
Именования коммитов и кол-во изменений в одном коммите - большая и сложная тема, вот основные моменты:  

* **Идентификатор задачи**  
    Сообщение или мета коммита должна иметь в себе идентификатор задачи.  
    Это позволит вашим коллегам и вам понимать, какую глобальную задачу решали те или иные коммиты.  
    Это знание не потеряется при увольнении сотрудника или приступе амнезии у оного,  
    и навсегда остается в истории коммитов и таск-трекере.  

    _Плохой пример:_  

    ```plain
    New role
    Fix role
    Fix fix
    ADMGROUP-124
    ```

* **Размер и стиль сообщения**  
    В идеале должно быть не меньше 8 и не больше 52 символов  
    Избегайте:

      * использования языка, отличного от американского английского
      * попыток нумеровать коммиты
      * нерелевантной информации
      * размашистых оборотов речи
      * сложных времен для глаголов
      * большого кол-ва вспомогательных слов

    _Плохой пример:_  

    ```plain
    This is my new fancy role for DNS Slave deployment. I have wrote it cause old role was makin' me sad. It' s rockin' hard!
    Новая роль для ДНС.
    Dns role 2.
    ```

* **Смысл сообщения**  
    Не дублируйте в сообщении то, что и так видно в коммите.  
    Если неочевиден смысл изменений, то нужно пояснить ПОЧЕМУ изменения именно такие.  
    Если смысл очевиден, то просто дайте общее название данным изменениям.  

    _Плохой пример:_  

    ```plain
    Changes 'no' to 'false' in role 'rsyslog'
    ```

_Пример хорошего сообщения коммита:_  

```plain
ADMGROUP-124 Initial role
ADMGROUP-124 Lint role
ADMGROUP-124 Fix typos
ADMGROUP-124 Idemptotence for DNS reload
```

### Ветки

Мы используем ветку **master** для актуального состояния прода.  
Если что-то применено к проду, то оно должно быть в мастере.  
Всю разработку новых инструментов мы ведем в отдельных ветках одного из двух типов:

* **feature**  
    Ветки для разработки нового фукционала или доработки существующего.

* **bugfix**  
    Ветки для условно-оперативного исправления каких-либо проблем на проде или в работе инструментов.

_Мы не используем hotfix-ветки, т. к. они не имеют особенного смысла при отстутствии дев-ветки и релизных веток._  

Ветки именуются след. образом:  
`тип_ветки/идентификатор_задачи-краткое_описание`  

_Пример:_  

```bash
feature/ADMGROUP-124-new-dns-role
feature/SUPPORT-39-rpndzr-db-hosts
feature/MGMT-81-updated-salary-rules

bugfix/ADMGROUP-124-revert-global-repo-url
bugfix/SUPPORT-39-remove-dublicates
bugfix/MGMT-81-fix-mistyped-salaries
```

### Реквесты

### Code review

Предполагается, что с Git-репозиторием работают все участники команды.  
Каждый участник понимает задачу по-своему и имеет свое представление о стиле\качестве написания кода,  
покрытия его тестами, подборе алгоритмов и конструкций применяемого языка.  
Для приведения всего этого творчества в единный стрим, существует набор различных style guide, устанавливаемых внутри команды.  
Подобные соглашения являются результатом фиксации общих договоренностей и необходимы для того,  
чтобы результат деятельности каждого из членов команды был легко читаем и воспринимаем для каждого в команде,  
соответствовал требования по производительности, переносимости и иным факторам, отраженным в style guide.  

Code review процесс призван обнаружить и решить некоторые проблемы еще до того,  
как они будут слиты в мастер и смогут затронуть production или staging.  
Сode review "в вакууме" призван решить такие проблемы, как:  

* **Соответствие кода всем применяемым style guide**  
    Сливаемые ветки с кодом сразу же соответствуют style guide,  
    что решает большинство вопросов обслуживаемости кода
* **Обнаружение опечаток и прочих механический ошибок**  
    Опечатки и прочие человеческие ошибки, обнаруживаются линтерами и при ручной проверке
* **Обнаружение design-ошибок**  
    Применимо для достаточно крупных задач или полноценных модулей,  
    готовых к встраиванию или автономной работе.  
    При решении задачи исполнитель может как неверно интерпретировать задачу,  
    так и неверно оценить степень влияния собственных изменений на соседние участки системы.  
    Посредством review от коллег легко обнаружить такие design-ошибки, как:  

    * Неоптимальные алгоритмы  
    * Недостаточная идемпотентность  
    * Отсутствие проверок работоспособности  
    * Несовместимость с текущей архитектурой  

* **Повышение общего уровня владения кодом**  
    Регулярный анализ кода членами группы приводит к тому, что практически все члены группы знакомятся как с новым,  
    так и со старым кодом, что серьезно снижает [фактор автобуса](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80_%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D0%B0).

#### Что инспектировать в review

Code review это практика, пришедшая из мира разработчиков.  
Тем не менее, для code review подходит абсолютно любой код независимо от того,  
на каком (псевдо)языке он написан.  
В идеале инспектируется весь код, но идеал зачастую недостижим,  
поэтому совершенно точно должны проходить review критичные участки кода/систем/сервисов:

* Соответствие style guide  
    Это проще всего, но важно, ибо [_теория разбитых окон_](https://www.psychologos.ru/articles/view/teoriya-razbityh-okon)
* Аутентификация, авторизация, отсутствие хардкода с секьюрными данными
* Механизмы обработки критичных данных
* Механизмы получения, верификации и обработки информации из внешних источников
* Механизмы обработки транзакций
* Механизмы обновления и выкатки изменений
* Механизмы тестирования кода

#### Кто и как проводит review

В разных командах это устроено по-разному, почти всегда это отражено в style guide или wiki рядом.  
При существенных размерах группы, review проводят более опытные коллеги, которые выделяют для этого некотороe время.  
Если группа не очень большая, то review проводится всеми членами команды,  
при этом не нужно страдать параноей, контрольной группы членов команды достаточно.

Code review бывает нескольких типов:

* Post-commit
    Review кода после внесения изменений в ветку на сервер контроля версий.  
    Подразумевает использование инструментов для коллективного review: gitlab/github/etc  
* Pre-commit
    Review до коммита в систему контроля версий.  
    Атавизм, практически не используется в современных командах.

#### Полезные практики code review

Ниже собран набор советов для code review практик:

* **Не сливайте ветки важных участков кода без code review**  
    Зачем это нужно - описано выше
* **Уважайте время своих коллег**  
    Выделяйте время на code review коллег.  
    Если реквест "висит" без review продолжитeльное время, то результат работы вашего коллеги не может быть использован.  
    Это значит, что он либо сорвет дедлайн, либо старался зря.  
    Помните, что вашим реквестам тоже понадобится review.  
    Code review - важная работа, не нужно воспринимать это как что-то,  
    что делается "на о̶т̶в̶а̶л̶и̶ отъебись", или как повод поебланить в рабочее время.  
* **Обязательно включайте в review коллег предыдущего грейда**  
    Анализ кода коллегами грейдом ниже является эффективным способом прокачки.  

## Типовые задачи в Git

### Схлопнуть несколько локальных коммитов в один

Закончили тестирование в отдельной ветке, и хотим подчистить дублирующие коммиты.

* Бэкапим в отдельный бранч на всякий случай `git branch my_backup_branch`
* Вызываем `git cherry -v master`, считаем глубину до нижнего коммита, который мы хотим сжать.  
    **Внимательно** проверяем, что на этой глубине **нет merge-коммитов**.  
    Если они есть, то схлопнуть этим коммиты **не получится**.  
* Делаем `git rebase -i HEAD~N`, где N - кол-во коммитов на сжатие  
    _Можно ограничить глубину вывода истории: `git log -10`_  
* Откроется редактор  с редактированием списка коммитов  
    _Редактор может быть разным, зависит от переменной окружений EDITOR._  
    _Точно нормально работает с Vim/nano/emacs/mcedit._  
      * верхний коммит трогать нельзя  
      * для "лишних" коммитов заменяем pick на s  
      * сохраняемся, выходим  
* Откроется редактор сообщения коммита, используем творческую силу, сохраняем, выходим  
* Повторно вызываеем `git cherry -v master`, проверяй, что теперь все выглядит правильно  
* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  

### Найти правки в строках N1-N2 файле X

Знаем, что в строках 6-8 файла README были правки, которые нам все сломали.  
Ищем коммиты, которые меняли эти строки:  

```bash
git blame -L 6,8 README.md
^756c345 (Sergei Mikhailov 2019-11-07 19:00:13 +0300 6)
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 7) ## Ручной запуск тестов
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 8)
```

Смотрим информацию по последнему коммиту:  

```bash
git show e0b9f53a README.md
commit e0b9f53a7e461053f7bf099231bf6a35dfbc1c1b (HEAD -> feature/common-pain, origin/feature/common-pain)
Author: Sergei Mikhailov <s.mikhaylov@tgk-ws.ru>
Date:   Fri Nov 8 12:07:32 2019 +0300

    Basic lint

diff --git a/README.md b/README.md
index a89f606..cc1bcc5 100644`
--- a/README.md
+++ b/README.md
@@ -1,6 +1,12 @@
 # StyleConvention

-В этом репо живут наши соглашения о работе с различными инструментами.
+В этом репо живут наши соглашения о работе с различными инструментами.
 Правки применяются только через Merge Request с апрувом(посредством емодзи) от большинства сотрудников.
 За корректностью разметки и текстов приглядыют автотесты.

+## Ручной запуск тестов
+
+### markdownlint
+
+`docker run -it -v "$PWD:/code" pipelinecomponents/markdownlint:5d96213 mdl -s md.rb -w .`
```

### Откатить файл X на коммит Y

В рамках задачи MYTEAM-19 обнаружили, что коммит *e0b9f53a* ломает наш любимый README.md.  
Создаем отдельную ветку:

```bash
git branch bugfix/MYTEAM-19
git push --set-upstream origin bugfix/MYTEAM-19
```

Откатываем файл README.md на один коммит ранее *e0b9f53a*:

```bash
git reset e0b9f53a~1 README.md
Unstaged changes after reset:
M       README.md
```

Закидываем эти правки:

```bash
git commit -m 'MYTEAM-19 Revert to e0b9f53a~1 due to broken func'
git push
```

### Подтянуть себе правки из мастера и порешать конфликты

В веб-интерфейсе видим, что смерджить бранч *create-wobbler-role* нельзя: есть конфликты.  
Если до этого мы не делали merge-коммиты, то самым удобным будет сделать rebase.

* Проверяем, что все правки добавлены в коммиты:  
    `git status`

* Бэкапим в отдельный бранч на всякий случай:  
    `git branch my_backup_branch`

* Делаем rebase:

    ```bash
    git rebase origin/master
    First, rewinding head to replay your work on top of it...
    Applying: Update README.md
    Applying: check docker-compose
    Applying: check docker-compose1
    Applying: check docker-compose2
    Applying: check docker-compose3
    Applying: check docker-compose4
    Using index info to reconstruct a base tree...
    A       inventory/group_vars/t1000/all
    Falling back to patching base and 3-way merge...
    CONFLICT (modify/delete): inventory/group_vars/t1000/all deleted in HEAD and modified in check docker-compose4.
                              Version check docker-compose4 of inventory/group_vars/t1000/all left in tree.
    error: Failed to merge in the changes.
    Patch failed at 0006 check docker-compose4
    hint: Use 'git am --show-current-patch' to see the failed patch

    Resolve all conflicts manually, mark them as resolved with
    "git add/rm <conflicted_files>", then run "git rebase --continue".
    You can instead skip this commit: run "git rebase --skip".
    To abort and get back to the state before "git rebase", run "git rebase --abort".
    ```

* Теперь нужно решить конфликты. Следуем подсказкам git:

    ```bash
    git rm inventory/group_vars/t1000/all
    git rebase --continue
    git rebase --skip
    ```

    _В данном случае нам не нужно мерджить конфликты в файле, мы его просто удаляем, как его уже удалили в мастере._

* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  
