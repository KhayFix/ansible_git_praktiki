# Ansible

* [Intro](#intro)  
    * [Что такое Ansible](#что-такое-ansible)  
    * [Структура](#структура)  
    * [Установка окружения](#установка-окружения)  
* [Практики](#практики)  
    * [Именование](#именование)  
    * [Переменные](#переменные)  
        * [Имя переменной](#имя-переменной)  
        * [Место объявления переменной](#место-объявления-переменной)  
        * [Форматирование определения](#форматирование-определения)  
        * [If в переменных](#if-в-переменных)  
        * [Python2 в теле переменных](#python2-в-теле-переменных)  
        * [Усы](#усы)  
    * [Таски](#таски)  
        * [Размер main.yml](#размер-mainyml)  
        * [Become в тасках](#become-в-тасках)  
        * [Set_fact](#set-fact)  
        * [File mode](#file-mode)  
        * [Использование shell и command](#использование-shell-и-command)  
    * [Хэндлеры](#хэндлеры)  
    * [Шаблоны и файлы](#шаблоны-и-файлы)  
        * [Имена файлов и шаблонов](#имена-файлов-и-шаблонов)  
        * [Шаблоны для конфигов в json и yaml](#шаблоны-для-конфигов-в-json-и-yaml)  
    * [Мета](#мета)  
    * [Доп. плагины](#доп-плагины)  
    * [Роли](#роли)  
    * [Плэйбуки](#плэйбуки)  
    * [Vault](#vault)  
* [CI/CD](#ci/cd)  
    * [Автотесты](#автотесты)  
    * [Автодеплой](#автодеплой)  
* [Антипаттеры](#антипаттеры)  
    * [копипаста ролей их внешних источников](#копипаста-ролей-их-внешних-источников)  
    * [отключение тестов](#отключение-тестов)  
    * [длинные строки](#длинные-строки)

## Intro

### Что такое Ansible

> **Ansible** — система управления конфигурациями, написанная на Python, с использованием  
декларативного языка разметки для описания конфигураций. Используется для автоматизации  
настройки и развертывания программного обеспечения.  
> (c) Wikipedia

Главные отличия от Chef, Pupppet и прочих систем конфигурации:

* **Не** клиент-серверная архитектура (для конфигурации целевого хоста не нужен агент).
* Чистый Python под капотом (для конфигурации целевого хоста достаточно иметь там Python).
* Оперирует только состояниями системы (обеспечивает идемпотентность для большинства изменений).
* Большая библиотека модулей в базовой поставке.
* Простота написания новых модулей/фильтров/плагинов.
* YAML в качестве языка разметки.

Кроме того, с некоторыми оговорками умеет в управление Windows-системами.

### Структура

  Описание изменений опирается на таски (task), каждая из которых представляют собой модуль  
(module) с именем (name), в который передаются необходимые для выполнения модуля параметры.
Кроме параметров самого модуля таск может содержать дополнительные параметры, необходимые  
для выполнения самого таска и/или вызова каких-либо действий (например декларация условий  
через **when:** или вызов хэндлеров (handler) через **notify:**).

  Логически связанные серии тасков и необходимые для их выполнения сущности (переменные,  
файлы, шаблоны) группируются в роли (role). Преполагается, что роль должна быть идемпотентной
и независимой (многократный запуск роли не меняет состояния системы и для выполнения роли не нужны  
никакие внешние зависимости).

  Логически связанная последовательность ролей и дополнительные сущности (переменные более высокого  
уровня, inventiry, лимиты) называется плэйбук (playbook). Предполагается, что плэйбук содержит в себе  
только настройки, высокоуровневые переменные и последовательность запуска ролей (с минимальной  
динамической логикой запуска).

### Установка окружения

* Устанавливаем [pyenv](https://github.com/pyenv/pyenv-installer)
* Устанавливаем нужные версии Python:

```bash
    pyenv install 2.7.16
    pyenv install 3.7.4
```

* Создаём venv с нужной версией:

```bash
    pyenv virtualenv 3.7.4 ansible_2.8.4
    pyenv local ansible_2.8.4
```

* Устанавливаем нужные пакеты:

```bash
    pip install requirments.txt
```

Чего **НЕ** стоит делать, если не хочется потом долго дебажить откуда подтянулся модуль старой версии  
и сломал выполнение роли или плэйбука:

* Использовать системный Python и его модули.
* Использовать Python2 (кроме случаев, когда он нужен из-за legacy-кода).
* Устанавливать в окружение пакеты с автоматическим разрешением зависимостей
  (``pip install ansible==2.8.4`` вместо ``pip install requirments.txt``).
* Использовать зависимости, которые ставятся **НЕ** через pip.
  (_кроме редких случаев, когда они дейстивтельно необходимы, но только при согласовании с командой и  
  с детальной документацией_).

## Практики

Ansible дает возможность выполнить одни и те же задачи большим количеством способов,  
поэтому ниже представлены препдочтительные способы решения тех или иных задач.

### Именование

Имена сущностей внутри проекта Ansible должны быть максиально очевидными.

### Переменные

#### Имя переменной

Имя переменной должно включать в себе имя роли, которая будет использовать эту переменную.  
Вы или ваши коллеги не должны грепать роли в случае, если они обнаружили неизвестную им переменную в group\_vars или host\_vars.  
Недопустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_zones: {}
default_dns_resolver: 8.8.8.8
```

Допустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_slave_zones: {}
dns_slave_default_resolver: 8.8.8.8
```

В случае, если вам нужна **глобальная переменная**,  
которую будут **использовать несколько ролей** этой нужно явно отразить в имени переменной.  
Кроме того, нужно явно указать использование этой переменной в defaults роли, и добавить _default_ на случай отсутствия глобальной переменной.

Недопустимо:

```yaml
# group_vars/all.yml
dns_slave_zones: {}

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/templates/config.j2
dns_zones = {{ dns_slave_zones }}
```

Допустимо:

```yaml
# group_vars/all.yml
global_dns_slave_zones: {}

# roles/dns_slave/defaults/main.yml
dns_slave_zones: "{{ global_dns_slave_zones | default({}) }}"

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/defaults/main.yml
exabgp_slave_zones: "{{ global_dns_slave_zones }}"

# roles/exabgp/templates/config.j2
dns_zones = {{ exabgp_slave_zones }}
```

#### Место объявления переменной

Все переменные, которые будет использовать роль, нужно объявлять в _корень\_роли/defaults/main.yml_ с дефольными\пустыми значениями.  
Это позволяет не заглядывая в таски и шаблоны понять, какие переменные доступны в данной роли, и упрощает дальнейшую работу с group_vars.  
Не рекомендуется задавать переменные в _корень\_роли/vars_,
т. к. они [выбиваются](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#id36) из последовательности работы с переменными.  

#### Форматирование определения

Избегайте больших и\или нечитабельных конструкций внутри переменных.
Если сократить размер не получается, то используйте многострочные конструкции с отступами.

Неудачно:  

```yaml
dns_slave_custom_zones: "{{ ( my_custom_data|to_some_data_convertion|to_other_data_convertion).split(';')|sort|get_first_10 }}"
```

Допустимо:  

```yaml
dns_slave_custom_zones: >
  {{
    (
      my_custom_data |
      to_some_data_convertion |
      to_other_data_convertion
    ).split(';') |
    sort |
    get_first_10
  }}
```

#### If в переменных

Избегайте использования _if_.  
В большинстве простых конструкций его легко можно заменить на _ternary_ или _default_.  

Неудачно:

```yaml
raw_resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] }}{% endif %}"

resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] | some_filtering }}{% endif %}"
```

Допустимо:  

```yaml
raw_resources: "{{ pacemaker['resources'] | default('') }}"

resources: >
  {{
    ('resources' in pacemaker) |
    ternary((pacemaker['resources'] | some_filtering), '')
  }}
```

#### Python2 в теле переменных

Избегайте использования python-функций, которые существуют только в python2:

* set
    Разобраться, в каких случаях работает, а в каких - нет.  
    Предложить альтернативы.  
* iteritems()  
    заменить на `items()`

#### Усы

  Между "усами" и значениями внутри них должны быть пробелы.  
  Плохо: `var: "{{key}}"`  
  Нормально: `var: "{{ key }}"`  

  Использовать "усы" в теле `when` и `assert` не требуется.  
  Плохо: `when: "{{ my_variable == 'test_value' }}"`  
  Нормально: `when: "my_variable == 'test_value'"`  

### Таски

#### Размер main.yml

Не рекомендуется излишне раздувать _main.yml_.  

* если он занимает более одного скролла экрана, то задумайтесь о создании отдельных файлов,  
    в которых будут логически сгруппированы таски.  

* если вы делаете инклуды в _main.yml_, то унесите из него все остальные таски.  
    В нем должны быть либо только таски, либо только инклуды\импорты.

* если у вас в тасках много условий на виды или версии дистрибутивов или других фактов.  

    ```yaml
    - name: Apache install tasks
      include_tasks: "install_apache_{{ ansible_distribution | lower }}"
    ```

  ```bash
  ls tasks
  tasks/main.yml
  tasks/install_apache_centos.yml
  tasks/install_apache_ubuntu.yml
  ```

    _Для более детального указания можно использовать готовый шаблон:_  
    `ansible_distribution_lower_ver: "{{ (ansible_distribution | lower) }}_{{ ansible_distribution_major_version }}"`

#### Become в тасках

Удачным решением будет задавать `become: true` на уровне плэйбука.  
Это позволит не определять _become_ в каждой таске, но оставит возможность явно отключить _become_ там, где он мешает.  
Пример - _become_ при использовании `delegate_to: localhost`.  
Также это помжет избегать бессмысленной копипасты `owner: root` и `group: root` при создании файлов и папок.

#### Set_fact

* если ты сэтишь факты в тасках, то скорее всего где-то обосрался
* обновить факты можно через повторный вызов _setup_
* не завязывайся на то, что приедет после setup других хостов: с лимитом ты обосрешься

#### File mode

* `mode:  u=x,g=x,o=x` - пиздец. юзать полный цифровой вид, `mode: 0755`

#### Использование shell и command

* шелл - почти нельзя.  
    и комманд - тоже
* таски должны уметь в чек-мод

### Хэндлеры

* без шелла, если ты не мудак
* юзай листен, если на разных системых нужно по-разному
* `notify: Systemctl daemon reload`  
    Не забывай при изменении конфигов systemd

### Шаблоны и файлы

#### Имена файлов и шаблонов

Логично будет назвать шаблон так, чтобы по его имени было понятно, какую функцию он выполняет, и\или где он будет после шаблонизации.  
Хуево: `src: template.j2`  
Допустимо:  

```yaml
    src: snmp_exporter.service.j2
    src: etc/systemd/system/snmp_exporter.service.j2
```

#### Шаблоны для конфигов в json и yaml

hui_data_struct| to_nice_yaml() /thread

### Мета

Или как пойти нахуй с бесполезными файлами в случае монорепо.

### Доп. плагины

Почему только на python, и как писать, чтоб оно не ебло мозг

### Роли

Что должны покрывать роли и как их понять, сколько пихать в одну роль

### Плэйбуки

Что и как должен делать плэйбук, и почему это не просто запускатор ролей

### Vault

или почему я твою мамку голой видел

## CI/CD

на месте, пидор

### Автотесты

* общие линтеры
* линтеры на каждую роль
* юниты и инты на роль

### Автодеплой

* интеграционные на тестовые площадки
* дифф на прод
* реальный на прод
* ОТКАТЫВАЙ, ОТКАТЫВАЙ

## Антипаттеры

у нас за такое убивают нахуй

### копипаста ролей их внешних источников

тобi пiзда  
и за ansible-galaxy - тоже

### отключение тестов

тобi пiзда прямо сразу

### длинные строки

тобi пiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiзда
