# Ansible

* [Intro](#intro)  
    * [Что такое Ansible](#что-такое-ansible)  
    * [Структура](#структура)  
    * [Установка окружения](#установка-окружения)  
        * [Анти-паттерны установки](#анти-паттерны-установки)  
* [Практики](#практики)  
    * [Именование](#именование)  
    * [Переменные](#переменные)  
        * [Имя переменной](#имя-переменной)  
        * [Место объявления переменной](#место-объявления-переменной)  
        * [Форматирование определения](#форматирование-определения)  
        * [If в переменных](#if-в-переменных)  
        * [Python2 в теле переменных](#python2-в-теле-переменных)  
        * [Усы](#усы)  
    * [Таски](#таски)  
        * [Размер main.yml](#размер-mainyml)  
        * [Become в тасках](#become-в-тасках)  
        * [Использование set_fact](#использование-set_fact)  
        * [Модули для работы с файлами](#модули-для-работы-с-файлами)  
        * [Использование shell и command](#использование-shell-и-command)  
        * [Использование raw](#использование-raw)  
    * [Хэндлеры](#хэндлеры)  
    * [Шаблоны и файлы](#шаблоны-и-файлы)  
        * [Имена файлов и шаблонов](#имена-файлов-и-шаблонов)  
        * [Шаблоны для конфигов в json и yaml](#шаблоны-для-конфигов-в-json-и-yaml)  
        * [Валидация сгенерированных файлов](#валидация-сгенерированных-файлов)  
    * [Мета](#мета)  
    * [Доп. плагины](#доп-плагины)  
    * [Роли](#роли)  
    * [Плэйбуки](#плэйбуки)  
    * [Vault](#vault)  
* [CI/CD](#ci/cd)  
    * [Автотесты](#автотесты)  
    * [Автодеплой](#автодеплой)  
* [Антипаттеры](#антипаттеры)  
    * [копипаста ролей их внешних источников](#копипаста-ролей-их-внешних-источников)  
    * [отключение тестов](#отключение-тестов)  
    * [длинные строки](#длинные-строки)

## Intro

### Что такое Ansible

> **Ansible** — система управления конфигурациями, написанная на Python, с использованием  
декларативного языка разметки для описания конфигураций.  
Используется для автоматизации настройки и развертывания программного обеспечения.  
> (c) Wikipedia

Главные отличия других систем конфигурации (_Chef\Pupppet\Salt_):

* Не требует агента на целевом хосте
* Не требует централизованного сервера для запуска
* Обеспечивает идемпотентность для большинства изменений
* Большой набор модулей в базовой поставке
* Простота написания новых модулей/фильтров/плагинов
* YAML в качестве языка разметки

Кроме того, с некоторыми оговорками Ansible умеет в управление FreeBSD/Windows/IOS/JunOS/etc

### Структура

_Пример структуры Ansible-проекта:_

```bash
.
├── ansible.cfg
├── group_vars -> inventory/group_vars
├── host_vars -> inventory/host_vars
├── inventory
│   ├── dns.yml
│   ├── gitlab_runner.yml
│   ├── group_vars
│   │   ├── all
│   │   │   └── users.yml
│   │   ├── gitlab_runner
│   │   │   └── gitlab-runner.yml
│   │   ├── dc1
│   │   │   └── all.yml
│   │   └── dc2
│   │       └── all.yml
│   └── host_vars
│       ├── dc1-dns01.yml
│       └── dc2-dns01.yml
├── README.md
├── requirments.txt
├── roles
│   ├── common
│   │   ├── sudo
│   │   │   ├── defaults
│   │   │   │   └── main.yml
│   │   │   ├── README.md
│   │   │   ├── tasks
│   │   │   │   └── main.yml
│   │   │   └── templates
│   │   │       └── sudoers.j2
│   │   ├── users
│   │   │   ├── defaults
│   │   │   │   └── main.yml
│   │   │   ├── handlers
│   │   │   │   └── main.yml
│   │   │   ├── README.md
│   │   │   └── tasks
│   │   │       └── main.yml
└── yamllint.yml
```

Описание желаемых состояний тех или иных объектов опирается на таски (task),  
каждая из которых представляют собой модуль(module) с именем (name),  
в который передаются необходимые для выполнения модуля параметры.  
Кроме параметров самого модуля таск может содержать дополнительные параметры, необходимые  
для выполнения самого таска и/или вызова каких-либо действий  
_например декларация условий через **when:**_  
_или вызов хэндлеров (handler) через **notify:**_

Логически связанные серии тасков и необходимые для их выполнения сущности  
(переменные, файлы, шаблоны, хэндлеры) группируются в роли (role).  
Преполагается, что роль должна быть [идемпотентной](https://medium.com/@ahmadfarag/idempotency-764f7bb6e4e2)  
и минимально зависимой от других ресурсов внутри ansible.  
_Роль должна быть в состоянии запуститься без переменных, заданых за пределами роли._

Логически связанная последовательность ролей и дополнительные сущности  
(переменные более высокого уровня, inventory, лимиты) называется плэйбук (playbook).  
Предполагается, что плэйбук содержит в себе только настройки, высокоуровневые переменные и  
последовательность запуска ролей, с минимальной динамической логикой запуска.

Полное [описание](https://docs.ansible.com/ansible/2.8/reference_appendices/glossary.html) сущностей Ansible.

### Установка окружения

_Вам может понадобиться поставить dev-пакеты под вашу OS._  
_Пример для Ubuntu 19.04:_  
`build-essential libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev`  
`libsqlite3-dev libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev libffi-dev uuid-dev`

* Устанавливаем [pyenv](https://github.com/pyenv/pyenv-installer)
* Устанавливаем нужные версии Python:  

    ```bash
    pyenv install 2.7.16
    pyenv install 3.7.4
    ```

* Создаём venv с нужной версией:

    ```bash
    pyenv virtualenv 3.7.4 ansible_2.8.4
    pyenv local ansible_2.8.4
    ```

* Устанавливаем нужные пакеты:

    `pip install requirments.txt`

#### Анти-паттерны установки

Избегайте этих приемов при установке Ansible и его окружения.  
Это позволит избежать дебага странных проблем, и гарантировать работоспособность проекта не только на вашей машине.

* Использование системного Python и его модулей
* Использование Python2 (кроме случаев, когда он нужен из-за legacy-кода)
* Устанавка в окружение модулей с автоматическим разрешением зависимостей  
    Пример:
    `pip install ansible==2.8.4` вместо `pip install requirments.txt`
* Использование зависимостей, которые ставятся **НЕ** через pip  
    _Кроме редких случаев, когда они дейстивтельно необходимы, но только при согласовании с командой_  
    _и с детальной документацией по установке и использованию_

## Практики

Ansible дает возможность выполнить одни и те же задачи большим количеством способов,  
поэтому ниже представлены препдочтительные способы решения тех или иных задач.

### Именование

Имена сущностей внутри проекта Ansible должны быть максиально очевидными.

### Переменные

#### Имя переменной

Имя переменной должно включать в себе имя роли, которая будет использовать эту переменную.  
Вы или ваши коллеги не должны грепать роли в случае, если они обнаружили неизвестную им переменную в group\_vars или host\_vars.  

Недопустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_zones: {}
default_dns_resolver: 8.8.8.8
```

Допустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_slave_zones: {}
dns_slave_default_resolver: 8.8.8.8
```

В случае, если вам нужна **глобальная переменная**,  
которую будут **использовать несколько ролей** этой нужно явно отразить в имени переменной.  
Кроме того, нужно явно указать использование этой переменной в defaults роли, и добавить _default_ на случай отсутствия глобальной переменной.

Недопустимо:

```yaml
# group_vars/all.yml
dns_slave_zones: {}

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/templates/config.j2
dns_zones = {{ dns_slave_zones }}
```

Допустимо:

```yaml
# group_vars/all.yml
global_dns_slave_zones: {}

# roles/dns_slave/defaults/main.yml
dns_slave_zones: "{{ global_dns_slave_zones | default({}) }}"

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/defaults/main.yml
exabgp_slave_zones: "{{ global_dns_slave_zones | default({}) }}"

# roles/exabgp/templates/config.j2
dns_zones = {{ exabgp_slave_zones }}
```

#### Место объявления переменной

Все переменные, которые будет использовать роль, нужно объявлять в _корень\_роли/defaults/main.yml_ с дефольными\пустыми значениями.  
Это позволяет не заглядывая в таски и шаблоны понять, какие переменные доступны в данной роли, и упрощает дальнейшую работу с group_vars.  
Не рекомендуется задавать переменные в _корень\_роли/vars_, т.к. они  
[выбиваются](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#id36) из последовательности работы с переменными.  

#### Форматирование определения

Избегайте больших и\или нечитабельных конструкций внутри переменных.
Если сократить размер не получается, то используйте многострочные конструкции с отступами.

Неудачно:  

```yaml
dns_slave_custom_zones: "{{ ( my_custom_data|to_some_data_convertion|to_other_data_convertion).split(';')|sort|get_first_10 }}"
```

Допустимо:  

```yaml
dns_slave_custom_zones: >
  {{
    (
      my_custom_data |
      to_some_data_convertion |
      to_other_data_convertion
    ).split(';') |
    sort |
    get_first_10
  }}
```

#### If в переменных

Избегайте использования _if_.  
В большинстве простых конструкций его легко можно заменить на _ternary_ или _default_.  

Неудачно:

```yaml
raw_resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] }}{% endif %}"

resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] | some_filtering }}{% endif %}"
```

Допустимо:  

```yaml
raw_resources: "{{ pacemaker['resources'] | default('') }}"

resources: >
  {{
    ('resources' in pacemaker) |
    ternary((pacemaker['resources'] | some_filtering), '')
  }}
```

#### Python2 в теле переменных

Избегайте использования python-функций, которые существуют только в python2:

* set  
    Разобраться, в каких случаях работает, а в каких - нет.  
    Предложить альтернативы.  
* iteritems()  
    заменить на `items()`

#### Усы

  Между "усами" и значениями внутри них должны быть пробелы.  
  Плохо: `var: "{{key}}"`  
  Нормально: `var: "{{ key }}"`  

  Использовать "усы" в теле `when` и `assert` не требуется.  
  Плохо: `when: "{{ my_variable == 'test_value' }}"`  
  Нормально: `when: "my_variable == 'test_value'"`  

### Таски

#### Размер main.yml

Не рекомендуется излишне раздувать _main.yml_.  

* если он занимает более одного скролла экрана, то задумайтесь о создании отдельных файлов,  
    в которых будут логически сгруппированы таски.  

* если вы делаете инклуды в _main.yml_, то унесите из него все остальные таски.  
    В нем должны быть либо только таски, либо только инклуды\импорты.

* если у вас в тасках много условий на виды или версии дистрибутивов или других фактов.  

    ```yaml
    - name: Apache install tasks
      include_tasks: "install_apache_{{ ansible_distribution | lower }}"
    ```

  ```bash
  ls tasks
  tasks/main.yml
  tasks/install_apache_centos.yml
  tasks/install_apache_ubuntu.yml
  ```

    _Для более детального указания можно использовать готовый шаблон:_  
    `ansible_distribution_lower_ver: "{{ (ansible_distribution | lower) }}_{{ ansible_distribution_major_version }}"`

#### Become в тасках

Удачным решением будет задавать `become: true` на уровне плэйбука.  
Это позволит не определять _become_ в каждой таске, но оставит возможность явно отключить _become_ там, где он мешает.  
Пример - _become_ при использовании `delegate_to: localhost`.  
Также это поможет избегать бессмысленной копипасты `owner: root` и `group: root` при создании файлов и папок.

#### Использование set_fact

* Хорошая практика -- генерировать все необходимые переменные в _defaults/main.yml_. Это упрощает логику  
    выполнения тасок и делает их более читабельными.  
    Делать _set_fact_ в самих тасках стоит только если это **действительно** необходимо.

    (_пример:_ генерация переменной на основе выхлопа предыдущей таски)

* Модуль _set_fact_ предназначен для генерации одиночных переменных. Поэтому, несмотря на то, что есть  
    методы создания многоуровневых _dict_of_dicts_of_lists_, если вам понадобились подобные вещи --
    вероятно что-то в вашей жизни пошло не так и пора остановиться и переосмыслить логику работы с переменными в этом месте.

* Исходя из предыдущего пункта: если вам понадобилось сгенерировать сложную многоуровневую структуру в  
    тасках -- стоит задуматься о написании своего [фильтра](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#filter-plugins).

* Иногда требуется обновить _ansible_facts_ после выполнения каких-то настроек на хосте. Для этого существует модуль _setup:_

    ```yaml
    - name: Update network-related variables in ansible_facts
      setup:
        gather_subset:
          - network
    ```

    Использование _gather_subset_ не обязательно, но значительно ускоряет время сборки фактов.

* Не стоит завязывать какую-то логику выполнения тасок на факты, собранные с других хостов, выполнение  
    плэйбука с указанием лимита приведёт к некорректному результату или ошибке выполнения.

#### Модули для работы с файлами

* При `become: true` в качестве пользователя и группы автоматически используется _root_.
    Указывать `owner: root` и `group: root` **не** нужно.

* При использовании _mode_ указывать полное цифровое значение как самое читаемое.  
    Использование `mode: preserve` приводит к долгому гаданию,  
    какие права доступа были у исходного файла/шаблона и должны ли они быть такими у целевого.

Недопустимо:  

```yaml
    mode: u=rw,g=r,o=r
    mode: u+rwx
    mode: preserve
```

Допустимо:  

```yaml
    mode: 0644
```

#### Использование shell и command

Модули _shell_ и _command_ отличаются от других стандартных модулей Ansible.

_shell_ и _command_ позволяют:

* выполить shell-команду (или команды) с использованием стандартной Python обвязки Ansible
* получить stdout, stderr и return code в возвращаемых модулем переменных

_shell_ и _command_ **НЕ** позволяют:

* использовать `check_mode` (выполнение модулей пропускается)
* гарантировать идемпотентность изменений (вне зависимости от результата статус модуля _Changed_)
* полагаться на стандартный обработчик ошибок Ansible.

Поэтому использовать _shell_ и _command_ **КРАЙНЕ** не рекомендуется. Скорее всего для выполнения нужных действий есть стандартный модуль.

Если его нет -- есть смысл задуматься о написании собственного [модуля](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html).

#### Использование raw

Модуль _raw_ выполняет shell-команды через ssh прямо на удалённом хосте, минуя при этом любые Python-обвзяки Ansible.

Использовать _raw_ допустимо только там, где нет и не может быть установлен Python.

### Хэндлеры

Хэндлеры -- крайне удобная вещь. Ими стоит пользоваться во всех ситуациях, когда действие нужно выполнить по  
изменению в таске. Хэндлеры по своей сути не сильно отличаются от обычных тасок и к ним стоит те же самые  
практики, не забывая при этом о специфике:

* Не использовать _shell_ и _command_ без крайней необходимости.
* Объявлять хэндлеры только в зарезервированном для них месте: `handlers/main.yml`
* В случае перезапуска _systemd_ юнита не забывать о изменении конфига:

    ```yaml
        - name: restart vmevict service
          systemd:
            name: vmevict
            state: restarted
            daemon_reload: true
    ```

* Имена хэндлеров должны быть уникальны, иначе из списка хэндлеров с одинаковыми именами выполниться только последний.
* Поэтому для выполнения нескоольких хэндлеров, объединённых логически в один блок, нужно использовать _listen:_

  Не сработает:

    ```yaml
        # roles/front/handlers/main.yml
        - name: restart front services
          systemd:
            name: front-app1
            state: restarted

        - name: restart front services
          systemd:
            name: front-app2
            state: restarted

        # roles/front/tasks/main.yml
        - name: Change some configs
          template:
            src: front.conf.j2
            dest: '/usrl/local/{{ item }}/front.conf.j2'
          loop:
            - 'front-app1'
            - 'front-app2'
          notify: "restart front services"
    ```

  Cработает:

    ```yaml
        # roles/front/handlers/main.yml
        - name: restart front-app1 service
          systemd:
            name: front-app1
            state: restarted
          listen: "restart front services"

        - name: restart front-app2 service
          systemd:
            name: front-app2
            state: restarted
          listen: "restart front services"

        # roles/front/tasks/main.yml
        - name: Change some configs
          template:
            src: front.conf.j2
            dest: '/usrl/local/{{ item }}/front.conf.j2'
          loop:
            - 'front-app1'
            - 'front-app2'
          notify: "restart front services"
    ```

* Хэндлеры выполняются в порядке объявления в `handlers/main.yml`, а не в порядке перечисления внутри _notify_:
* Несмотря на то, что в именах хэндлеров могут быть переменные, использовать их не стоит. Мало того, что эти  
    переменные шаблонизируются перед выполнением тасок и могут оказаться пустыми в этот момент, так они  
    ещё и не изменят имя хэндлера при изменении переменной посреди выполнения тасок.
* В глобальной конфигурации Ansible есть параметр, отвечающий за механизм обработки хэндлеров. Не стоит  
    менять его с дефолтного значения, если только вы не невидите своих коллег.
* Если нужно выполнить хэндлеры раньше, чем закончится выполнение роли, используйте:

```yaml
    - name: Run handlers immediatly
      meta: flush_handlers
```

### Шаблоны и файлы

#### Имена файлов и шаблонов

Логично будет назвать шаблон так, чтобы по его имени было понятно, какую функцию он выполняет, и\или где он будет после шаблонизации.  
Хуево: `src: template.j2`  
Допустимо:  

```yaml
    src: snmp_exporter.service.j2
    src: etc/systemd/system/snmp_exporter.service.j2
```

#### Шаблоны для конфигов в json и yaml

hui_data_struct| to_nice_yaml() /thread

#### Валидация сгенерированных файлов

### Мета

Или как пойти нахуй с бесполезными файлами в случае монорепо.

### Доп. плагины

Почему только на python, и как писать, чтоб оно не ебло мозг

### Роли

Что должны покрывать роли и как их понять, сколько пихать в одну роль

### Плэйбуки

Что и как должен делать плэйбук, и почему это не просто запускатор ролей

### Vault

или почему я твою мамку голой видел

## CI/CD

на месте, пидор

### Автотесты

* общие линтеры
* линтеры на каждую роль
* юниты и инты на роль

### Автодеплой

* интеграционные на тестовые площадки
* дифф на прод
* реальный на прод
* ОТКАТЫВАЙ, ОТКАТЫВАЙ

## Антипаттеры

у нас за такое убивают нахуй

### копипаста ролей их внешних источников

тобi пiзда  
и за ansible-galaxy - тоже

### отключение тестов

тобi пiзда прямо сразу

### длинные строки

тобi пiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiзда
