# Git

## Зачем

Мы храним в git-репо наши инструменты: проекты Ansible, Terraform, и даже эту документацию.  
Git дает нам  следующие возможности:  

* **Версионность изменений**  
    Позволяет нам вносить правки осмысленными частями(коммитами).  
    Вся история коммитов всегда доступна для просмотра и поиска.  
* **Обратимость изменений**  
    Мы всегда можем откатить до определенного коммита как весь репозиторий, так и только несколько файлов.  
    Работает поиск по изменениям, и мы всегда можем найти коммит, в котором были внесены те или иные изменения.  
* **Независимость изменений**  
    До момент слияния нашей ветки с другой веткой мы не испытываем никакого влияния изменений из других веток.
* **CI**  
    Мы можем прогонять автоматизированные действия как на каждый коммит, так и при определенных условиях.  
    Это позволяет реализовать различные автотесты и автовыкладки.  
* **Ревью изменений**  
    Позволяет нам удобно проводить коллективную оценку изменений перед их слиянием с другими ветками.

## Как

### Коммиты

Коммит - минимальная единца изменений в Git.  
Именования коммитов и кол-во изменений в одном коммите - большая и сложная тема, вот основные моменты:  

* **Идентификатор задачи**  
    Сообщение или мета коммита должна иметь в себе идентификатор задачи.  
    Это позволит вашим коллегам и вам понимать, какую глобальную задачу решали те или иные коммиты.  
    Это знание не потеряется при увольнении сотрудника или приступе амнезии у оного,  
    и навсегда остается в истории коммитов и таск-трекере.  

    _Плохой пример:_  

    ```plain
    New role
    Fix role
    Fix fix
    ADMGROUP-124
    ```

* **Размер и стиль сообщения**  
    В идеале должно быть не меньше 8 и не больше 52 символов  
    Избегайте:

    * использования языка, отличного от американского английского  
    * попыток нумеровать коммиты
    * нерелевантной информации  
    * размашистых оборотов речи  
    * сложных времен для глаголов  
    * большого кол-ва вспомогательных слов.  

    _Плохой пример:_  

    ```plain
    This is my new fancy role for DNS Slave deployment. I have wrote it cause old role was makin' me sad. It' s rockin' hard!
    Новая роль для ДНС.
    Dns role 2.
    ```

* **Смысл сообщения**  
    Не дублируйте в сообщении то, что и так видно в коммите.  
    Если неочевиден смысл изменений, то нужно пояснить ПОЧЕМУ изменения именно такие.  
    Если смысл очевиден, то просто дайте общее название данным изменениям.  

    _Плохой пример:_  

    ```plain
    Changes 'no' to 'false' in role 'rsyslog'
    ```

_Пример хорошего сообщения коммита:_  

```plain
ADMGROUP-124 Initial role
ADMGROUP-124 Lint role
ADMGROUP-124 Fix typos
ADMGROUP-124 Idemptotence for DNS reload
```

### Ветки

Мы используем ветку **master** для актуального состояния прода.  
Если что-то применено к проду, то оно должно быть в мастере.  
Всю разработку новых инструментов мы ведем в отдельных ветках одного из двух типов:

* **feature**  
    Ветки для разработки нового фукционала или доработки существующего.

* **bugfix**  
    Ветки для условно-оперативного исправления каких-либо проблем на проде или в работе инструментов.

_Мы не используем hotfix-ветки, т. к. они не имеют особенного смысла при отстутствии дев-ветки и релизных веток._  

Ветки именуются след. образом:  
`тип_ветки/идентификатор_задачи-краткое_описание`  

_Пример:_  

```bash
feature/ADMGROUP-124-new-dns-role
feature/SUPPORT-39-rpndzr-db-hosts
feature/MGMT-81-updated-salary-rules

bugfix/ADMGROUP-124-revert-global-repo-url
bugfix/SUPPORT-39-remove-dublicates
bugfix/MGMT-81-fix-mistyped-salaries
```

### Реквесты/ревью

## Инструменты и примеры

### Схлопнуть несколько локальных коммитов в один

Закончили тестирование в отдельной ветке, и хотим подчистить дублирующие коммиты.

* Бэкапим в отдельный бранч на всякий случай `git branch my_backup_branch`
* Вызываем `git cherry -v master`, считаем глубину до нижнего коммита, который мы хотим сжать.  
    **Внимательно** проверяем, что на этой глубине **нет merge-коммитов**.  
    Если они есть, то схлопнуть этим коммиты **не получится**.  
* Делаем `git rebase -i HEAD~N`, где N - кол-во коммитов на сжатие  
    _Можно ограничить глубину вывода истории: `git log -10`_  
* Откроется редактор  с редактированием списка коммитов  
    _Редактор может быть разным, зависит от переменной окружений EDITOR._  
    _Точно нормально работает с Vim/nano/emacs/mcedit._  
    * верхний коммит трогать нельзя  
    * для "лишних" коммитов заменяем pick на s  
    * сохраняемся, выходим  
* Откроется редактор сообщения коммита, используем творческую силу, сохраняем, выходим  
* Повторно вызываеем `git cherry -v master`, проверяй, что теперь все выглядит правильно  
* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  

### Найти правки в строках N1-N2 файле X

Знаем, что в строках 6-8 файла README были правки, которые нам все сломали.  
Ищем коммиты, которые меняли эти строки:  

```bash
git blame -L 6,8 README.md
^756c345 (Sergei Mikhailov 2019-11-07 19:00:13 +0300 6)
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 7) ## Ручной запуск тестов
e0b9f53a (Sergei Mikhailov 2019-11-08 12:07:32 +0300 8)
```

Смотрим информацию по последнему коммиту:  

```bash
git show e0b9f53a README.md
commit e0b9f53a7e461053f7bf099231bf6a35dfbc1c1b (HEAD -> feature/common-pain, origin/feature/common-pain)
Author: Sergei Mikhailov <s.mikhaylov@tgk-ws.ru>
Date:   Fri Nov 8 12:07:32 2019 +0300

    Basic lint

diff --git a/README.md b/README.md
index a89f606..cc1bcc5 100644`
--- a/README.md
+++ b/README.md
@@ -1,6 +1,12 @@
 # StyleConvention

-В этом репо живут наши соглашения о работе с различными инструментами.
+В этом репо живут наши соглашения о работе с различными инструментами.
 Правки применяются только через Merge Request с апрувом(посредством емодзи) от большинства сотрудников.
 За корректностью разметки и текстов приглядыют автотесты.

+## Ручной запуск тестов
+
+### markdownlint
+
+`docker run -it -v "$PWD:/code" pipelinecomponents/markdownlint:5d96213 mdl -s md.rb -w .`
```

### Откатить файл X на коммит Y

В рамках задачи MYTEAM-19 обнаружили, что коммит *e0b9f53a* ломает наш любимый README.md.  
Создаем отдельную ветку:

```bash
git branch bugfix/MYTEAM-19
git push --set-upstream origin bugfix/MYTEAM-19
```

Откатываем файл README.md на один коммит ранее *e0b9f53a*:

```bash
git reset e0b9f53a~1 README.md
Unstaged changes after reset:
M       README.md
```

Закидываем эти правки:

```bash
git commit -m 'MYTEAM-19 Revert to e0b9f53a~1 due to broken func'
git push
```

### Подтянуть себе правки из мастера и порешать конфликты

В веб-интерфейсе видим, что смерджить бранч *create-wobbler-role* нельзя: есть конфликты.  
Если до этого мы не делали merge-коммиты, то самым удобным будет сделать rebase.

* Проверяем, что все правки добавлены в коммиты:  
    `git status`

* Бэкапим в отдельный бранч на всякий случай:  
    `git branch my_backup_branch`

* Делаем rebase:

    ```bash
    git rebase origin/master
    First, rewinding head to replay your work on top of it...
    Applying: Update README.md
    Applying: check docker-compose
    Applying: check docker-compose1
    Applying: check docker-compose2
    Applying: check docker-compose3
    Applying: check docker-compose4
    Using index info to reconstruct a base tree...
    A       inventory/group_vars/t1000/all
    Falling back to patching base and 3-way merge...
    CONFLICT (modify/delete): inventory/group_vars/t1000/all deleted in HEAD and modified in check docker-compose4.
                              Version check docker-compose4 of inventory/group_vars/t1000/all left in tree.
    error: Failed to merge in the changes.
    Patch failed at 0006 check docker-compose4
    hint: Use 'git am --show-current-patch' to see the failed patch

    Resolve all conflicts manually, mark them as resolved with
    "git add/rm <conflicted_files>", then run "git rebase --continue".
    You can instead skip this commit: run "git rebase --skip".
    To abort and get back to the state before "git rebase", run "git rebase --abort".
    ```

* Теперь нужно решить конфликты. Следуем подсказкам git:

    ```bash
    git rm inventory/group_vars/t1000/all
    git rebase --continue
    git rebase --skip
    ```

    _В данном случае нам не нужно мерджить конфликты в файле, мы его просто удаляем, как его уже удалили в мастере._

* **Внимательно** проверяем ветку, на которой находимся:
    это должна быть исходная ветка, и ни в коем случае **НЕ МАСТЕР**.  
    Убедитесь, что вы работаете над этой веткой один, иначе вы можете затереть коммиты ваших коллег.
* `git push`  
    Он должен выдать ошибку о расхождении данных в локальном и удаленном репо.  
* `git push --force`  
    После проверяем в веб-версии, что все изменилось так, как мы и хотели  

## Code review

Предполагается, что Git-репозиторием работают все участники команды.  
Каждый участник понимает задачу по-своему и имеет свое представление о стиле\качестве написания кода,  
покрытия его тестами, подборе алгоритмов и конструкций применяемого языка.  
Для приведения всего этого творчества в единный стрим, существует набор различных style guide, устанавливаемых внутри команды.  
Подобные соглашения являются результатом фиксации общих договоренностей и необходимы для того,  
чтобы результат деятельности каждого из членов комманды был легко читаем и воспринимаем для каждого в команде,  
соответствовал требования по производительности, переносимости и иным факторам, отраженным в style guide.  

Code review процесс призван обнаружить и решить некоторый список проблем еще до того,  
как они будут смержены в продакшен или стейджинг-окружения.  
Ниже некоторый список проблем, которые code review призван решить в идеале:  
*  **Соответствие кода всем применяемым style guide**  
   Сливаемые ветки с кодом сразу же соответствуют style guide и не требуют правки в последующем, отвлекая от полезной  
   работы
*  **Находятся и устраняются опечатки и прочие механические ошибки**  
   Все мы люди, возможны опечатки и прочие механические ошибки, которые не отсекаются на этапе певой очереди  
   тестирования, а больно обнаруживаются уже в реальной работе в хитросплетениях бизнес-логики
*  **Находятся и устраняются design ошибки кода**  
   Применимо для достаточно крупных задач или полноценных модулей, готовых к встраиванию или автономной работы.  
   Зачастую при решении задачи, участник группы может не верно интерпретировать задачу или драматично не верно оценить  
   уровень влияния результата выполнения задачи на соседние участки компекта ПО. Например могут использоваться не  
   верные алгоритмы, которые обладают не приемлемой сложностью, ломать архитектуру приложения/системы и пр., что  
   приводит к невозможности использования результата работы целиком либо без существенной доработки.
*  **Повышается общий уровень владения кодом**  
   Постоянные процессы анализа кода членов комманды, приводит к тому, что практически все члены группы знакомятся с  
   новинками и новым кодом еще до его реального применения, при этом серьезно снижается фактор автобуса

#### Что можно инспектировать
Code review это практика, пришедшая из мира разработчиков. Тем не менее, для code review подходит абсолютно любой код  
не зависимо от того, на каком ЯП или не ЯП он написан. В идеале инспектируется весь код, но идеал зачастую не достижим,  
по этому совершенно точно должны проходить review критичные участки кода/систем/сервисов:
*  Соответствие style guide. Это проще всего, но помойка в доме начинается с первого брошенного фантика
*  Аутентификация, авторизация
*  Механизмы обработки критичных данных
*  Механизмы получения, ферификации и обработки информации из внешних источников
*  Механизмы обработки транзакций
*  Механизмы обновления и выкатки изменений
*  Механизмы тестирования, хорошо подходят для review unit-тесты

#### Кто и как проводит review
В разных коммандах это устроенно по разному, почти всегда это отражено в style guide или wiki рядом.  
При существенных размрах группы, review проводят более опытные коллеги, которые выделяют для этого некоторо время.  
Если группа не очень большая, то review проводится всеми членами комманды, при этом не нужно страдать параноей,  
контрольной группы членов комманды достаточно.

Code review бывает нескольких типов:
*  Pre-commit. Когда review проводит до коммита в систему контроля версий, обычно применяется совместно и другими  
   гибкими практиками (Практически не используется)
*  Post-commit. Review кода после внесения изменений в ветку на сервер контроля версий. Сопровождается  
   использованием инструментов code review различных систем вроде: gitlab, github, gerrit и пр.


### Полезные практики code review
Ниже собран набор советов для code review практик:
*  **Не сливайте ветки важных участков кода без code review**  
   Зачем это нужно - описано выше
*  **Уважайте время своих коллег**  
   Выделяйте время на code review коллег. Мердж реквесты могут висеть продолжитльное время без review и все это время  
   результат работы твоего коллги не может быть использован. Это значит, что он либо сорвет дедлайн, либо старался зря.  
   Завтра точно так же повиснет твой реквест в ожидании review. Code review не менее важная работа, чем написание кода
*  **Review должен проводить коллега, обладающий соответствующими компетенциями**  
   Review кода сеньера джуном не может быть эфективным. Проводящий review кода коллега должен обладать уровнем  
   компетенций равным либо выше отправившего мердж реквест. Но есть и исключения
*  **Обязательно включайте в review коллег предыдущего грейда**  
   Анализ кода мидлов джунами и синьеров мидлами - лучший способ быстро поднять скилл коллег. Глядя на реальный код,  
   применяемые подходы и трюки, коллеги быстро подтягиваются и перенимают подходы к написанию кода. Все это в  
   последствии приводит к более быстрому бутстрапу новичков и к единообразию подходов и технических решений, что в свою  
   очередь упрощает дальнейшее развитие и сопровождение кода всей коммандой.
*  **Design review как можно раньше**  
   Чем раньше вы поймете, что коллега свернул не в ту сторону, тем меньше будет потрачено его и общих сил и времени.