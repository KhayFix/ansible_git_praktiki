# Ansible

* [Intro](#intro)  
  * [Что такое Ansible](#что-такое-ansible)  
  * [Структура](#структура)  
  * [Установка окружения](#установка-окружения)  
    * [Антипаттерны установки](#антипаттерны-установки)  
* [Практики](#практики)  
  * [Именование](#именование)  
  * [Переменные](#переменные)  
    * [Имя переменной](#имя-переменной)  
    * [Глобальные переменные](#глобальные-переменные)  
    * [Место объявления переменной](#место-объявления-переменной)  
    * [Форматирование определения](#форматирование-определения)  
    * [If в переменных](#if-в-переменных)  
    * [Python2 в теле переменных](#python2-в-теле-переменных)  
    * [Усы](#усы)  
  * [Таски](#таски)  
    * [Размер main.yml](#размер-mainyml)  
    * [Become в тасках](#become-в-тасках)  
    * [Использование set_fact](#использование-set_fact)  
    * [Модули для работы с файлами](#модули-для-работы-с-файлами)  
    * [Использование shell и command](#использование-shell-и-command)  
    * [Использование raw](#использование-raw)  
  * [Хэндлеры](#хэндлеры)  
  * [Шаблоны](#шаблоны)  
    * [Имена файлов и шаблонов](#имена-файлов-и-шаблонов)  
    * [Шаблоны для конфигов в json и yaml](#шаблоны-для-конфигов-в-json-и-yaml)  
    * [Валидация сгенерированных файлов](#валидация-сгенерированных-файлов)  
  * [Мета](#мета)  
  * [Доп. плагины](#доп-плагины)  
  * [Роли](#роли)  
    * [Переменные роли](#переменные-роли)  
    * [Что делает роль](#что-делает-роль)  
    * [Требования к роли](#требования-к-роли)  
    * [Минимальный чеклист для роли](#минимальный-чеклист-для-роли)  
  * [Плэйбуки](#плэйбуки)  
    * [Структура плэйбука](#структура-плэйбука)  
    * [Параметры плэйбука](#параметры-плэйбука)  
  * [Vault](#vault)  
  * [Асинхронный режим](#асинхронный-режим)  
* [CI/CD](#ci/cd)  
  * [Автотесты](#автотесты)  
  * [Автодеплой](#автодеплой)  
* [Антипаттерны](#антипаттерны)  
  * [копипаста ролей их внешних источников](#копипаста-ролей-их-внешних-источников)
  * [отключение тестов](#отключение-тестов)
  * [длинные строки](#длинные-строки)

## Intro

### Что такое Ansible

> **Ansible** — система управления конфигурациями, написанная на Python, с использованием  
декларативного языка разметки для описания конфигураций.  
Используется для автоматизации настройки и развертывания программного обеспечения.  
> (c) Wikipedia

Главные отличия других систем конфигурации (_Chef\Puppet\Salt_):

* Не требует агента на целевом хосте
* Не требует централизованного сервера для запуска
* Обеспечивает идемпотентность для большинства изменений
* Большой набор модулей в базовой поставке
* Простота написания новых модулей/фильтров/плагинов
* YAML в качестве языка разметки

Кроме того, с некоторыми оговорками Ansible умеет в управление FreeBSD/Windows/IOS/JunOS/etc

### Структура

_Пример структуры Ansible-проекта:_

```bash
.
├── ansible.cfg
├── group_vars -> inventory/group_vars
├── host_vars -> inventory/host_vars
├── inventory
│   ├── dns.yml
│   ├── gitlab_runner.yml
│   ├── group_vars
│   │   ├── all
│   │   │   └── users.yml
│   │   ├── gitlab_runner
│   │   │   └── gitlab-runner.yml
│   │   ├── dc1
│   │   │   └── all.yml
│   │   └── dc2
│   │       └── all.yml
│   └── host_vars
│       ├── dc1-dns01.yml
│       └── dc2-dns01.yml
├── README.md
├── requirments.txt
├── roles
│   ├── common
│   │   ├── sudo
│   │   │   ├── defaults
│   │   │   │   └── main.yml
│   │   │   ├── README.md
│   │   │   ├── tasks
│   │   │   │   └── main.yml
│   │   │   └── templates
│   │   │       └── sudoers.j2
│   │   ├── users
│   │   │   ├── defaults
│   │   │   │   └── main.yml
│   │   │   ├── handlers
│   │   │   │   └── main.yml
│   │   │   ├── README.md
│   │   │   └── tasks
│   │   │       └── main.yml
└── yamllint.yml
```

Описание желаемых состояний тех или иных объектов опирается на таски (task),  
каждая из которых представляют собой модуль(module) с именем (name),  
в который передаются необходимые для выполнения модуля параметры.  
Кроме параметров самого модуля таск может содержать дополнительные параметры, необходимые  
для выполнения самого таска и/или вызова каких-либо действий  
_например декларация условий через **when:**_  
_или вызов хэндлеров (handler) через **notify:**_

Логически связанные серии тасков и необходимые для их выполнения сущности  
(переменные, файлы, шаблоны, хэндлеры) группируются в роли (role).  
Предполагается, что роль должна быть [идемпотентной](https://medium.com/@ahmadfarag/idempotency-764f7bb6e4e2)  
и минимально зависимой от других ресурсов внутри ansible.  
_Роль должна быть в состоянии запуститься без переменных, заданных за пределами роли._

Логически связанная последовательность ролей и дополнительные сущности  
(переменные более высокого уровня, inventory, лимиты) называется плэйбук (playbook).  
Предполагается, что плэйбук содержит в себе только настройки, высокоуровневые переменные и  
последовательность запуска ролей, с минимальной динамической логикой запуска.

Полное [описание](https://docs.ansible.com/ansible/2.8/reference_appendices/glossary.html) сущностей Ansible.

### Установка окружения

**Disclaimer**  
_Разумеется, ваша рабочая машина - ваша зона ответственности, и никто не указывает вам, как управлять окружениями на ней._  
_На вкус и цвет все фломастеры разные,̶ т̶о̶л̶ь̶к̶о̶ ̶г̶о̶л̶у̶б̶о̶й̶ ̶н̶е̶ ̶в̶к̶у̶с̶н̶ы̶й._  
_Однако учтите, что вы должны быть в состоянии оперативно переключаться между версиями python и его модулей._  
_Если вы не знаете, как управлять окружениями python, то вот инструкция по установке независимых окружений._  
_При выборе данного варианта вам потребуется ознакомиться с [документацией к pyenv](https://github.com/pyenv/pyenv/blob/master/README.md)._

_Вам может понадобиться поставить dev-пакеты под вашу OS._  
_Пример для Ubuntu 19.04:_  
`build-essential libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev`  
`libsqlite3-dev libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev libffi-dev uuid-dev`

* Устанавливаем [pyenv](https://github.com/pyenv/pyenv-installer)  
    _Не забудьте запустить новую сессию в терминале после этого._

* Устанавливаем нужные версии Python:  

    ```bash
    pyenv install 2.7.16
    pyenv install 3.7.4
    ```

* Создаём venv для нашего репо:

    ```bash
    pyenv virtualenv 3.7.4 our_repo_name
    pyenv local our_repo_name
    ```

* Устанавливаем нужные пакеты из корня нашего репо:

    `pip install -r requirments.txt`

#### Антипаттерны установки

Избегайте этих приемов при установке Ansible и его окружения.  
Это позволит избежать дебага странных проблем, и гарантировать работоспособность проекта не только на вашей машине.

* Использование системного Python и его модулей
* Использование Python2 (кроме случаев, когда он нужен из-за legacy-кода)
* Установка в окружение модулей с автоматическим разрешением зависимостей  
    Пример:
    `pip install ansible==2.8.4` вместо `pip install -r requirments.txt`
* Использование зависимостей, которые ставятся **НЕ** через pip  
    _Кроме редких случаев, когда они действительно необходимы, но только при согласовании с командой_  
    _и с детальной документацией по установке и использованию_

## Практики

Ansible дает возможность выполнить одни и те же задачи большим количеством способов,  
поэтому ниже представлены предпочтительные способы решения тех или иных задач.

### Именование

Имена сущностей внутри проекта Ansible должны быть максимально очевидными.

### Переменные

#### Имя переменной

Допустимо использование только [snake_case](https://ru.wikipedia.org/wiki/Snake_case).  
Имя переменной должно включать в себе имя роли, которая будет использовать эту переменную.  
Вы или ваши коллеги не должны грепать роли в случае, если они обнаружили неизвестную им переменную в group\_vars или host\_vars.  

Недопустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_zones: {}
default_dns_resolver: 8.8.8.8
```

Допустимо:

```yaml
# roles/dns_slave/defaults/main.yml
dns_slave_zones: {}
dns_slave_default_resolver: 8.8.8.8
```

#### Глобальные переменные

В случае, если вам нужна **глобальная переменная**,  
которую будут **использовать несколько ролей** этой нужно явно отразить в имени переменной.  
Кроме того, нужно явно указать использование этой переменной в defaults роли, и добавить _default_ на случай отсутствия глобальной переменной.

Недопустимо:

```yaml
# group_vars/all.yml
dns_slave_zones: {}

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/templates/config.j2
dns_zones = {{ dns_slave_zones }}
```

Допустимо:

```yaml
# group_vars/all.yml
global_dns_slave_zones: {}

# roles/dns_slave/defaults/main.yml
dns_slave_zones: "{{ global_dns_slave_zones | default({}) }}"

# roles/dns_slave/templates/config.j2
dns_zones = {{ dns_slave_zones }}

# roles/exabgp/defaults/main.yml
exabgp_slave_zones: "{{ global_dns_slave_zones | default({}) }}"

# roles/exabgp/templates/config.j2
dns_zones = {{ exabgp_slave_zones }}
```

#### Место объявления переменной

Все переменные, которые будет использовать роль, нужно объявлять в _корень\_роли/defaults/main.yml_ с дефолтными\пустыми значениями.  
Это позволяет не заглядывая в таски и шаблоны понять, какие переменные доступны в данной роли, и упрощает дальнейшую работу с group_vars.  
Не рекомендуется задавать переменные в _корень\_роли/vars_, т.к. они  
[выбиваются](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#id36) из последовательности работы с переменными.  

#### Форматирование определения

Избегайте больших и\или нечитабельных конструкций внутри переменных.
Если сократить размер не получается, то используйте многострочные конструкции с отступами.

Неудачно:  

```yaml
dns_slave_custom_zones: "{{ ( my_custom_data|to_some_data_convertion|to_other_data_convertion).split(';')|sort|get_first_10 }}"
```

Допустимо:  

```yaml
dns_slave_custom_zones: >
  {{
    (
      my_custom_data |
      to_some_data_convertion |
      to_other_data_convertion
    ).split(';') |
    sort |
    get_first_10
  }}
```

#### If в переменных

Избегайте использования _if_.  
В большинстве простых конструкций его легко можно заменить на _ternary_ или _default_.  

Неудачно:

```yaml
raw_resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] }}{% endif %}"

resources: "{%if 'resources' in pacemaker %}{{ pacemaker['resources'] | some_filtering }}{% endif %}"
```

Допустимо:  

```yaml
raw_resources: "{{ pacemaker['resources'] | default('') }}"

resources: >
  {{
    ('resources' in pacemaker) |
    ternary((pacemaker['resources'] | some_filtering), '')
  }}
```

#### Python2 в теле переменных

Избегайте использования python-функций, которые существуют только в python2:

* iteritems()  
    заменить на `items()`
* iterkeys()  
    использовать прямую итерацию по словарю, пример:  

    ```python
    for dict_key in my_dict:
      print(dict_key)
    ```

#### Усы

  Между "усами" и значениями внутри них должны быть пробелы.  
  Плохо: `var: "{{key}}"`  
  Нормально: `var: "{{ key }}"`  

  Использовать "усы" в теле `when` и `assert` не требуется.  
  Плохо: `when: "{{ my_variable == 'test_value' }}"`  
  Нормально: `when: "my_variable == 'test_value'"`  

### Таски

#### Размер main.yml

Не рекомендуется излишне раздувать _main.yml_.  

* если он занимает более одного скролла экрана, то задумайтесь о создании отдельных файлов,  
    в которых будут логически сгруппированы таски.  

* если вы делаете инклуды в _main.yml_, то унесите из него все остальные таски.  
    В нем должны быть либо только таски, либо только инклуды\импорты.

* если у вас в тасках много условий на виды или версии дистрибутивов или других фактов.  

    ```yaml
    - name: Apache install tasks
      include_tasks: "install_apache_{{ ansible_distribution | lower }}"
    ```

  ```bash
  ls tasks
  tasks/main.yml
  tasks/install_apache_centos.yml
  tasks/install_apache_ubuntu.yml
  ```

    _Для более детального указания можно использовать готовый шаблон:_  
    `ansible_distribution_lower_ver: "{{ (ansible_distribution | lower) }}_{{ ansible_distribution_major_version }}"`

#### Become в тасках

Удачным решением будет задавать `become: true` на уровне плэйбука.  
Это позволит не определять _become_ в каждой таске, но оставит возможность явно отключить _become_ там, где он мешает.  
Пример - _become_ при использовании `delegate_to: localhost`.  
Также это поможет избегать бессмысленной копипасты `owner: root` и `group: root` при создании файлов и папок.

#### Использование set_fact

* Хорошая практика -- генерировать все необходимые переменные в _defaults/main.yml_. Это упрощает логику  
    выполнения тасок и делает их более читабельными.  
    Делать _set_fact_ в самих тасках стоит только если это **действительно** необходимо.

    (_пример:_ генерация переменной на основе выхлопа предыдущей таски)

* Модуль _set_fact_ предназначен для генерации одиночных переменных. Поэтому, несмотря на то, что есть  
    методы создания многоуровневых _dict_of_dicts_of_lists_, если вам понадобились подобные вещи --
    вероятно что-то в вашей жизни пошло не так и пора остановиться и переосмыслить логику работы с переменными в этом месте.

* Исходя из предыдущего пункта: если вам понадобилось сгенерировать сложную многоуровневую структуру в  
    тасках -- стоит задуматься о написании своего [фильтра](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#filter-plugins).

* Иногда требуется обновить _ansible_facts_ после выполнения каких-то настроек на хосте. Для этого существует модуль _setup:_

    ```yaml
    - name: Update network-related variables in ansible_facts
      setup:
        gather_subset:
          - network
    ```

    Использование _gather_subset_ не обязательно, но значительно ускоряет время сборки фактов.

* Не стоит завязывать какую-то логику выполнения тасок на факты, собранные с других хостов, выполнение  
    плэйбука с указанием лимита приведёт к некорректному результату или ошибке выполнения.

#### Модули для работы с файлами

* При `become: true` в качестве пользователя и группы автоматически используется _root_.
    Указывать `owner: root` и `group: root` **не** нужно.

* При использовании _mode_ указывать полное цифровое значение как самое читаемое.  
    Использование `mode: preserve` приводит к долгому гаданию,  
    какие права доступа были у исходного файла/шаблона и должны ли они быть такими у целевого.

Недопустимо:  

```yaml
    mode: u=rw,g=r,o=r
    mode: u+rwx
    mode: preserve
```

Допустимо:  

```yaml
    mode: 0644
```

#### Использование shell и command

Модули _shell_ и _command_ отличаются от других стандартных модулей Ansible.

_shell_ и _command_ позволяют:

* выполнить shell-команду (или команды) с использованием стандартной Python обвязки Ansible
* получить stdout, stderr и return code в возвращаемых модулем переменных

_shell_ и _command_ **НЕ** позволяют:

* использовать `check_mode` (выполнение модулей пропускается)
* гарантировать идемпотентность изменений (вне зависимости от результата статус модуля _Changed_)
* полагаться на стандартный обработчик ошибок Ansible.

Поэтому использовать _shell_ и _command_ **КРАЙНЕ** не рекомендуется. Скорее всего для выполнения нужных действий есть стандартный модуль.

Если его нет -- есть смысл задуматься о написании собственного [модуля](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html).

#### Использование raw

Модуль _raw_ выполняет shell-команды через ssh прямо на удалённом хосте, минуя при этом любые Python-обвязки Ansible.

Использовать _raw_ допустимо только там, где нет и не может быть установлен Python.

### Хэндлеры

Хэндлеры -- крайне удобная вещь. Ими стоит пользоваться во всех ситуациях, когда действие нужно выполнить по  
изменению в таске. Хэндлеры по своей сути не сильно отличаются от обычных тасок и к ним стоит те же самые  
практики, не забывая при этом о специфике:

* Не использовать _shell_ и _command_ без крайней необходимости.
* Объявлять хэндлеры только в зарезервированном для них месте: `handlers/main.yml`
* В случае перезапуска _systemd_ юнита не забывать о изменении конфига:

    ```yaml
        - name: restart vmevict service
          systemd:
            name: vmevict
            state: restarted
            daemon_reload: true
    ```

* Имена хэндлеров должны быть уникальны, иначе из списка хэндлеров с одинаковыми именами выполниться только последний.
* Поэтому для выполнения нескольких хэндлеров, объединённых логически в один блок, нужно использовать _listen:_

  Не сработает:

    ```yaml
        # roles/front/handlers/main.yml
        - name: restart front services
          systemd:
            name: front-app1
            state: restarted

        - name: restart front services
          systemd:
            name: front-app2
            state: restarted

        # roles/front/tasks/main.yml
        - name: Change some configs
          template:
            src: front.conf.j2
            dest: '/usrl/local/{{ item }}/front.conf.j2'
          loop:
            - 'front-app1'
            - 'front-app2'
          notify: "restart front services"
    ```

  Сработает:

    ```yaml
        # roles/front/handlers/main.yml
        - name: restart front-app1 service
          systemd:
            name: front-app1
            state: restarted
          listen: "restart front services"

        - name: restart front-app2 service
          systemd:
            name: front-app2
            state: restarted
          listen: "restart front services"

        # roles/front/tasks/main.yml
        - name: Change some configs
          template:
            src: front.conf.j2
            dest: '/usrl/local/{{ item }}/front.conf.j2'
          loop:
            - 'front-app1'
            - 'front-app2'
          notify: "restart front services"
    ```

* Хэндлеры выполняются в порядке объявления в `handlers/main.yml`, а не в порядке перечисления внутри _notify_:
* Несмотря на то, что в именах хэндлеров могут быть переменные, использовать их не стоит. Мало того, что эти  
    переменные шаблонизируются перед выполнением тасок и могут оказаться пустыми в этот момент, так они  
    ещё и не изменят имя хэндлера при изменении переменной посреди выполнения тасок.
* В глобальной конфигурации Ansible есть параметр, отвечающий за механизм обработки хэндлеров. Не стоит  
    менять его с дефолтного значения, если только вы не ненавидите своих коллег.
* Если нужно выполнить хэндлеры раньше, чем они сработают по умолчанию:

```yaml
    - name: Run handlers immediatly
      meta: flush_handlers
```

### Шаблоны

Шаблоны (templates) работают на jinja2 и поддерживают весь функционал джинджи плюс специфичные для Ansible  
  плагины. В итоге у нас есть очень мощный инструмент генерации содержимого файлов, который, однако,  
  подвержен скатыванию в нечитабельный ад.

Чтобы такого не происходило стоит придерживаться следующих правил:

* При любой возможности избегать сложных многоуровневых конструкций с `{% if %}` и `{% for %}` в шаблоне.  
    Нужные переменные стоит готовить в `defaults` или `tasks` в удобном формате.

  Неподдерживаемо:

    ```jinja2
        {% for item in role_item_dict %}
        {% if item.key == 'foo' %}
        {% set new_item = 'bar' %}
        {% for k,v in item['new_item'].value %}
        [{{ k }}]
        setting = {{ v }}
        {% endfor %}
        {% endif %}
        {% endfor %}
    ```

  Допустимо:

    ```jinja2
        {% for key, value in role_prepared_items %}
        [{{ key }}]
        setting = {{ value }}
        {% endfor %}
    ```

* Не стоит шаблонизировать те типы файлов, для изменения которых существуют модули (например `ini` или  
    `xml`). Модули справятся лучше.
* Нет никакой необходимости деплоить полностью статический файл как шаблон. Модуль `copy` справится  
    лучше.
* Хорошая практика -- добавлять в шапку шаблона `{{ ansible_managed }}`, чтобы явно указать, что файл не  
    нужно править руками.

#### Имена файлов и шаблонов

Логично будет назвать шаблон так, чтобы по его имени было понятно, какую функцию он выполняет и\или где он  
  будет после шаблонизации.

Недопустимо:  

```yaml
    src: template.j2
    src: templates/systemd/unit.j2
```

Допустимо:  

```yaml
    src: apt.conf.j2
    src: templates/systemd/snmp_exporter.service.j2
```

#### Шаблоны для конфигов в json и yaml

Если целевой конфиг в формате json или yaml, самым простым будет использовать фильтры `to_nice_json()` и  
  `to_nice_yaml()`. **НО** всегда нужно помнить о ограничениях этих фильтров:  

* Исходная структура в процессе рендеринга будет преобразована в питоновский словарь и проитерирована в  
    соответствии с питоновским механизмом обработки айтемов. Поэтому порядок элементов в итоговой  
    структуре может (_и будет_) отличаться от исходной и меняться в зависимости от версии Python.

* Фильтры не всегда верно парсят исходную структуру и ошибаются с отступами, лечится явным указанием  
    размера отступа `to_nice_json(indent=2)` или, в сложных случаях, фильтром `indent`.

В случаях, когда конфиг можно описать одной структурой и перечисленные выше ограничения не существенны,  
  достаточно использовать `copy` вместо `template`.

Пример:

```yaml
  - name: configure prometheus
    copy:
      content: "{{ prometheus_base_config | to_nice_yaml }}"
      dest: "/etc/prometheus/prometheus.yml"
      validate: "/usr/local/bin/promtool check config %s"
```

#### Валидация сгенерированных файлов

Очень хорошая практика -- включать валидацию сгенерированного файла в модуле `template`, если она возможна  
  (есть нужная команда). Это экономит уйму времени на дебаге и тестировании сгенерированных файлов и  
  позволяет узнать о ошибке шаблонизации немедленно, а не после финального неудачного перезапуска сервиса.

Пример:

  ```yaml
    - name: template sshd config with validation
      template:
        src: etc/ssh/sshd_config.j2
        dest: /etc/ssh/sshd_config
        mode: '0600'
        validate: /usr/sbin/sshd -t -f %s
  ```

Это справедливо и для модуля `copy`.

### Мета

Метаинформация о роли располагается в `role/meta/main.yml` и содержит информацию об авторе,  
  поддерживаемой версии Ansible, поддерживаемых версиях ОС, зависимостях от других ролей и прочую  
  дополнительную информацию.  

При этом подключение зависимостей с помощью меты в ролях является плохой практикой, потому что усложняет  
  понимание логики работы плэйбука.

Мета полезна, если:

* У вас роли и плэйбуки расположены в разных _локальных_ репозиториях и подключаются через ansible-galaxy с  
  помощью requirements.yml.
* Вы при этом хотите подключать роли в зависимости от метаинформации.

Мета бесполезна, если:

* У вас монорепозиторий.

### Доп. плагины

Почему только на python, и как писать, чтоб оно не ебло мозг

### Роли

Конечно, всё необходимое можно прописать в секцию _tasks:_ плэйбука, но такой подход резко перестаёт быть  
  поддерживаемым с появлением хотя бы пары-тройки плэйбуков с повторяющимися частями внутри. Поэтому  
  гораздо проще разделить нужные таски на логические группы и написать отдельные роли.  
  Плюсы такого подхода:  

* Переиспользование кода.
* Возможность вносить исправления только в одну сущность.
* Модульность и возможность выполнять только определённые части плэйбука.
* Расширенные возможности для тестирования.

Для того, чтобы эти плюсы реально работали, роли должны быть написаны с учётом определённых требований:  

#### Переменные роли

* Все переменные роли должны быть явно определены в _defaults/main.yml_. Если предполагается  использование  
    глобальных переменных (_group_vars, playbook scope, envs_) -- в _defaults_ должно быть их явное  
    переопределение с фоллбэком в случае отсутствия/пустоты глобальной переменной.

  См. [Глобальные переменные](#глобальные-переменные)

* К переменным применимы все требования именования и расположения, описанные выше.
* Дополнительные сущности (_файлы, шаблоны, фильтры, модули_) должны находится внутри директории  
  роли.

#### Что делает роль

На этот вопрос нет однозначного ответа, но неплохим подходом будет **смотреть на роль как на описание  
  сервиса**, то есть каждая роль должна полностью описывать один сервис и всё необходимое для его работы.  
  Это звучит очевидно для ролей, суть которых -- деплой сервиса и чуть менее понятно, если нужно лишь  
  выполнить какие-то настройки, поэтому вот пример небольшой инфраструктурной роли:

Допустим, нам нужно управлять локальными пользователями на удалённых серверах:  

* Создавать с различными параметрами
* Удалять пользователей
* Выдавать или отнимать повышенные привилегии через механизм sudo.

В таком случае логичными будет сделать отдельную роль, которая занимается управлением пользователями, то  
  есть создаёт нужные группы и пользователей с различными настройками (_homedir, shell, ssh keys_) и  
  удаляет пользователей тем или иным способом. И отдельную роль, которая добавляет нужных пользователей  
  в sudoers с определёнными привилегиями и удаляет их.

Это позволит использовать каждую роль, как "сервис" по управлению пользователями и настройке привилегий  
  независимо друг от друга.

#### Требования к роли

Написанное выше можно сформулировать в простой список требований:

* **Роль не должна иметь внешних зависимостей (изолированность).**  
  * Все необходимые переменные определены в _defaults_.
  * Внутри роли нет инклудов других ролей.
  * Все нужные шаблоны и файлы находятся в директории роли.

* **Роль должна быть идемпотентной.**  
    Повторное выполнение роли на тех же самых целевых хостах не должно вносить изменений.

* **Роль должна корректно работать в check mode.**  
    Запуск роли в check mode не должен завершаться с ошибкой или вносить реальные изменения.

#### Минимальный чеклист для роли

```bash
  # Check-mode и изоляция роли
  ansible-playbook -i inventory.yml -l host_subset site.yml --check

  # Идемпотентность и общая работоспособность
  ansible-playbook -i inventory.yml -l test_hosts site.yml --diff
```

  где _site.yml_ выглядит примерно так:

```yaml
  - name: bootstrap VM
    hosts: all
    become: true
    gather_facts: true

    roles:
      - role_name
```

### Плэйбуки

Плэйбук -- самый высокий уровень абстракции в Ansible.  
Он одновременно является точкой входа для выполнения сложных сценариев  
и инструментом настройки правильного окружения для них.  
Главная задача плэйбука -- свести запуск любого сложного сценария к простой команде:

  ```bash
    ansible-playbook -i inventory.yml playbook.yml
  ```

Как видно, в этой команде в идеальном случае, нет никаких дополнительных ключей, потому что все они определены в плэйбуке.  
Кроме того, есть параметры, которые могут быть определены **только** в плэйбуке.

#### Структура плэйбука

* Плэйбук может состоять из нескольких логически связанных между собой сценариев (_play_). При этом  
    import одного плэйбука в другой -- не самая хорошая практика, вместо этого стоит написать сценарий.

* Главное отличие одного сценария от другого -- список хостов, для которых этот сценарий будет запущен  
    (_- hosts:_). Поэтому стоит указывать список хостов или инвентари-группу и по возможности избегать  
    использования _hosts: all_.

* На уровне плэйбука стоит определять (и переопределять) глобальные переменные и переменные,  
    полученные из ansible_facts. Все более специфические вещи стоит определять на уровне ролей.

* В плэйбуке допустимо реализовывать дополнительную логику запуска ролей, но таски, вносящие изменения  
    на хосты, стоит вынести на уровень ролей.

* Перезапуск сервисов и перечитывание конфигов нужно выносить в хэндлеры соответствующих ролей.  
    Выносить подобные вещи в _post_tasks:_ плэйбука -- плохая идея.

Общий пример

Недопустимо:

```yaml
- hosts: all
  become: true
  gather_facts: true

  pre_tasks:
    - name: create nginx ssl dir
      file:
        state: directory
        path: /etc/nginx/ssl

  roles:
    - install_nginx

- hosts: prod_balancers
  become: true
  gather_facts: false

  roles:
    - config_nginx

  post_tasks:
    - name: restart nginx
      systemd:
        name: nginx
        state: restarted
```

Допустимо:

```yaml
- name: Deploy proxy
  become: true
  gather_facts: true
  hosts: prod-proxy
  roles:
    - firewall
    - nginx

- name: Deploy DB
  become: true
  gather_facts: true
  hosts: prod-db
  roles:
    - postgres

- name: Deploy app
  become: true
  gather_facts: true
  hosts: prod-app
  roles:
    - application
```

#### Параметры плэйбука

* Если для выполнения ролей нужны повышенные привилегии, то _become_ стоит определить на уровне плэйбука.

* Порядок итерации хостов во время выполнения можно менять параметром _order:_, но это стоит делать  
    только если вы абсолютно уверены в необходимости изменения дефолтного метода и остальные члены  
    команды с вами согласны.

* Хорошей практикой будет указывать _serial:_ для каждого сценария, **особенно** если этот плэйбук  
  используется для настройки продакшн окружения.

* Не стоит задавать список хостов переменной.

    ```yaml
      - hosts: '{{ host_group | default('all') }}'
    ```

  Запуск такого плэйбука с `--limit`  приведёт к неожиданным и не самым приятным результатам.

### Vault

Очень часто в переменных, особенно уровня _group__ и _host_vars_ приходится хранить секретные значения:  

* токены
* пароли
* важные для бизнеса параметры
* специфичные для конкретной среды настройки

В идеальном мире хранение и распределение доступа к секретам стоит возложить на специально написанные для  
  этого сервисы, например [Hashicorp Vault](https://www.vaultproject.io) или [Square Keywhiz](https://square.github.io/keywhiz/).  
  Но в реальности развёртывание и поддержка подобных систем ради хранения нескольких секретных токенов  
  может оказаться стрельбой из пушки по воробьям. Вместо этого проще и удобнее использовать шифрованное  
  хранилище [Ansible Vault](https://docs.ansible.com/ansible/latest/user_guide/vault.html).

Vault реализован в виде отдельной CLI-утилиты для управления хранилищем секретов (шифровка, расшифровка,  
  изменение паролей) и нативной поддержки в остальных `ansible-*` утилитах. При указанном через ключ или  
  переменную окружения пароле все `ansible-*` утилиты распознают зашифрованные данные и дешифруют их для  
  использования. Очевидно, что пароль от зашифрованных данных не должен храниться в этом же репозитории.  

Кроме этого есть ещё несколько особенностей:  

* зашифрованными могут быть как файлы целиком, так и отдельные переменные внутри простого файла.  
    Несмотря на то, что кажется удобным и читабельным хранить зашифрованные значения прямо внутри  _group_vars_, на самом деле первая же вынужденная смена паролей от шифрованных переменных покажет,  
    насколько это неподдерживаемо.  

    Поэтому стоит вынести все секретные переменные в отдельный файл и  
    зашифровать его целиком.  
    Пример:

    ```yaml
        group_vars/prod/main.yml

        database_pass: "{{ vault_database_pass }}"

        group_vars/prod/vault.yml

        vault_database_pass: W0WsuchS3cr3t
    ```

* описанный выше подход будет отлично работать, если у вас есть пароль от хранилища и вы готовы его  
  использовать. Но попытка выполнить команду, взаимодействующую с инвентори, но не требующую  
  расшифровки секретов (например, вызов `ansible -i inventory all --list-hosts` для проверки  
  валидности инвентори), закончится ошибкой расшифровки.  

  Поэтому стоит вынести шифрованный файл за пределы _*\_vars_ и подключать его в нужных плэйбуках.  
  Пример:

  ```yaml
    group_vars/prod/main.yml

    billing_api_token: "{{ vault_billing_api_token | default('TESTTOKEN') }}"

    vault/prod_secrets.yml

    vault_billing_api_token: SoR3STfull

    playbooks/front/deploy_billing_front.yml

  - name: Deploy PROD billing front
    hosts: prod_front
    become: true
    gather_facts: true
    vars_files:
      - vault/prod_secrets.yml
    roles:

  - name: Deploy STAGE billing front
    hosts: stage_front
    become: true
    gather_facts: true
    roles:
  ```

* Ansible Vault поддерживает возможность повесить несколько labels на хранилище и задать ему несколько  
    паролей для расшифровки. Это может быть удобно, но важно помнить, что лейблы ничего реально не  
    разграничивают и расшифрованы будут ВСЕ значения, которые зашифрованы указанным паролем.  

  То же самое и с несколькими паролями. Вне зависимости, какие пароли и с какими лэйблами вы укажете  
    ВСЕ указанные пароли будут применены ко ВСЕМ зашифрованным значениям (даже не имеющим лейблов) и  
    всё, что может быть этими паролями расшифровано -- будет расшифровано.

### Асинхронный режим

Ansible позволяет запустить отдельные таски в "асинхронном" режиме. Выглядит это примерно вот так:  

```yaml
- name: 'Pip async install'
  pip:
    name: {{ packages_list }}
    state: present
  async: 1000
  poll: 0
  register: pip_async

...

- name: 'Pip async check status'
  async_status:
    jid: "{{ pip_async.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 30
```

В таком режиме Ansible запустит таск `Pip async install` и, не дожидаясь её завершения начнёт выполнение  
  следующих тасок, пока не дойдёт до `Pip async check status`, в которой проверяется статус выполнения  
  установки пакетов. Плюсы этого режима очевидны: можно выполнять другие шаги настройки, не дожидаясь  
  завершения длительной установки. Но есть и минусы:

* Далеко не все модули могут корректно работать в async, особенно если они связаны с блокировкой ресурсов.
* Нужно чётко понимать, когда можно применить async и когда нужно проверить результат асинхронной таски.
* Асинхронные таски ломают идемпотентность роли, потому что всегда завершаются в состоянии _Changed_
* Логика работы async сильно усложняет понимание структуры роли.

Суммируя эти факты и добавляя личный опыт:  
  Использование асинхронного режима очень редко заметно ускоряет плэйбук и практически всегда ломает  
  автоматическое тестирование ролей.  
  **Поэтому нужно быть абсолютно уверенным, что пользы от него больше, чем неудобств и что все  
    члены  команды полностью понимают, что это и как оно работает.**

## CI/CD

Использование подхода "инфраструктура как код" позволяет использовать не только версионирование кода,  
но и другие полезные практики из мира разработки, которые можно логически объединить в категорию [**CI**](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F)/[**CD**](https://en.wikipedia.org/wiki/Continuous_delivery).

### Автотесты

Первая сложность при создании автотестов для Ansible-проекта - это поиск соответсвующего инструмента.  
Если отмести желание писать с нуля собственную платформу, то вариант один: [Molecule](https://molecule.readthedocs.io/en/stable/).  

Molecule рассчитана в первую очередь на тестирование ролей, поэтому для упрощения покрытия "кода"  
  тестами стоит в первую очередь перейти к модели, в которой все изменения вынесены в отдельные роли.  

  Второе важное уточнение: основным драйвером в Molecule является Docker, а тесты выполняются в  
  контейнерах. Поэтому если ваш CI/CD сервер также используется в контейнерах, то придётся задуматься  
  о _Docker-in-Docker_. А если планируется тестировать неконтейнеризованные сервисы -- настроить работу  
  _Systemd_ внутри DinD контейнера.

Теперь конкретика: Molecule обеспечивает роли полный набор тестов, включая линтеры, тестовый деплой,  
  проверку на идемпотентность, внешние unit-тесты с использованием Python-based фреймворков. Поэтому  
  тестирование роли выглядит примерно так:

* Линтеры (yamllint, ansible-lint, flake8). Проверяют соответствие кода общепринятым best practices и  
    специфичным для конкретных языков code styles.
* Тестовый деплой роли в подготовленный контейнер. Выявляет проблемы в функционале роли. Этот шаг имеет     смысл запускать с дефолтными переменными, чтобы проверить изоляцию роли.
* Второй деплой роли в тот же контейнер. Проверят идемпотентность роли.
* Внешние тесты (по умолчанию pytest+testinfra). Позволяют написать unit-тесты для проверки изменений,  
    вносимых ролью.

Кроме этого можно определять дополнительные шаги и менять порядок шагов. Это позволяет организовать  
  полноценное интеграционное тестирование с развёртыванием дополнительных сервисов для проверки  
  взаимодействия с ними.

Приблизительно структура тестирования для монорепозитория выглядит так:  

* `molecule lint` на изменения каждой роли на каждый коммит в feature/bugfix бранч.
* `molecule test` для полного сценария тестирования на изменения каждой роли на Merge Request в master  
    ветку.
* `yaml-lint` на каждый коммит в бранч на изменение всех `.yml` файлов за исключением ролей.
* `ansible-lint` на каждый коммит в бранч на изменение всех плэйбуков за исключением ролей.
* `ansible-playbook ... --check --diff` на изменения в плэйбуках на Merge Request в master.
* Линтеры для других типов файлов (например .md) на каждый коммит.

Примеры:

Запуск yamllint для нескольких .yml файлов

```bash
  yamllint -c yamllint_config.yml dir1 dir2 file1.yml
```

Запуск ansible-lint для всех плэйбуков в директории _playbooks_

```bash
  find playbooks -maxdepth 2 -type f -name '*.yml' | parallel -P 4 -I playbook unbuffer ansible-lint -p playbook
```

Запуск `molecule lint` для всех ролей в директории _roles_

```bash
  parallel 'cd {} && echo -e "\n$(pwd)\n" && molecule lint' ":::" $(find roles -mindepth 1 -maxdepth 1 -type d)
```

Проверка Ansible inventory

```bash
  export ANSIBLE_INVENTORY_ANY_UNPARSED_IS_FAILED: "true"
  yamllint -c yamllint_config.yml inventory
  ansible -i inventory all --list-hosts
```

### Автодеплой

* интеграционные на тестовые площадки
* дифф на прод
* реальный на прод
* ОТКАТЫВАЙ, ОТКАТЫВАЙ

## Антипаттерны

у нас за такое убивают нахуй

### копипаста ролей их внешних источников

не нужно так
и из ansible-galaxy - особенно

### отключение тестов

мгновенное отклонение Merge Request

### длинные строки

не нуууууужноооооооооооо таааааааааааааааааааааааак
